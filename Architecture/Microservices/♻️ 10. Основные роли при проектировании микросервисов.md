
Для создания законченного приложения требуются не только технические специалисты, поэтому мы считаем, что основа успешной разработки микросервисов начинается с вовлечения в процесс трех важнейших ролей:

- **архитектора** – видит общую картину, разбивает приложение на отдельные микросервисы, а затем определяет, как микросервисы будут взаимодействовать друг с другом для получения решения;
- **программиста** – пишет код и определяет, как использовать язык и фреймворки для создания микросервиса;
- **инженера DevOps** – определяет порядок развертывания служб и управления ими в промышленном и непромышленном окружениях. Девиз инженера DevOps: «Последовательность и повторяемость в любом окружении».


---

## Точка зрения архитектора: проектирование микросервисной архитектуры

Роль архитектора в проекте программного обеспечения – предложить рабочую модель задачи, которую нужно решить.

Архитектор формирует основу, на которой разработчики будут строить свой код и приводить в соответствие все части приложения.

При создании микросервисов архитектор проекта фокусируется на трех ключевых задачах:
- декомпозиции бизнес-задачи;
- детализации служб;
- определении интерфейсов.

### Декомпозиция бизнес-задачи

Большинство людей, столкнувшись со сложностями, пытаются разбить задачу, над которой они работают, на более простые подзадачи, чтобы не забивать голову множеством мелких деталей.

Они разбивают задачу на несколько основных частей, а затем определяют отношения, существующие между этими частями.

Архитектор разбивает бизнес-задачу на части, представляющие отдельные виды деятельности.

Эти части инкапсулируют **бизнес-правила** и **логику данных**, связанную с определенной частью предметной области.

Например, архитектор может взглянуть на бизнес-поток, который необходимо реализовать, и понять, что ему нужна информация как о покупателе, так и о продукте.

> Наличие двух отдельных видов данных является хорошим признаком того, что в игре может участвовать несколько микросервисов. Правила взаимодействий двух разных частей бизнес-транзакции обычно становятся служебным интерфейсом микросервиса.

Разбиение предметной области – это больше искусство, чем точная наука. Для выявления и выделения кандидатов на создание микросервисов можно использовать следующие рекомендации:

**Опишите бизнес-задачу и обратите внимание на существительные, которые вы используете.** Многократное использование одних и тех же существительных при описании задачи обычно является хорошим признаком некоторой подзадачи, которую можно организовать в виде отдельного микросервиса. Примерами таких существительных для приложения могут быть контракт, лицензии и активы.

**Обратите внимание на глаголы.** Глаголы выделяют действия и часто отмечают естественные контуры предметной области. Если вы обнаружите, что говорите: «Транзакция X должна получить данные от объектов A и B», – то это обычно указывает на присутствие в игре нескольких служб.

**Ищите тесно связанные данные.** Разбивая бизнес-задачу на отдельные части, ищите фрагменты данных, тесно связанные друг с другом. Если вдруг в процессе обсуждения обнаруживается необходимость чтения или обновления данных, которые радикально отличаются от того, что вы обсуждали, то это может указывать на еще одного кандидата в микросервисы. Микросервисы должны владеть только своими данными.


### Детализация служб

Чтобы выделить службы, опираясь на модель данных, недостаточно просто переупаковать код в отдельные проекты.

Необходимо также выделить таблицы в базе данных, к которым будут обращаться службы, и разрешить каждой службе обращаться только к своим конкретным таблицам.

На рисунке ниже показано, как код приложения и модель данных «разбиваются» на отдельные части.

> На рисунке созданы отдельные базы данных для каждой службы, но можно организовать совместное использование общей базы данных.

![Детализация служб](assets/Microservices/detail_sluzhba.png)

Вопрос детализации очень важен при создании микросервисной архитектуры. Основные концепции, которые помогут подобрать правильную степень детализации:

**Лучше сначала создать микросервис с широкой областью охвата, а затем выполнить рефакторинг и разбить его на более мелкие службы.** Вступая на путь создания микросервисов, легко переборщить и превратить в микросервисы все и вся. Однако разделение предметной области на большое количество мелких служб часто приводит к избыточной сложности, потому что микросервисы превращаются в службы, управляющие мелкими фрагментами данных.

**В первую очередь сосредоточьтесь на взаимодействиях служб.** Это поможет определить общие интерфейсы в предметной области. Слишком широкие службы проще реорганизовать, чем слишком мелкие.

**Круг обязанностей служб меняется с развитием нашего понимания предметной области.** Часто с появлением необходимости внедрения новых возможностей в приложение круг обязанностей микросервиса расширяется. То, что сначала было небольшим микросервисом, может разделиться на несколько служб, при этом исходный микросервис превращается в уровень оркестровки новых служб и инкапсулирует их функциональные возможности.


Если микросервис получился слишком большой, то вы, скорее всего, увидите:
- **службу со слишком широким кругом обязанностей.** Общий поток бизнес-логики в службе выглядит сложным и требует применения чрезмерно разнообразного набора правил;
- **службу, которая управляет данными в большом количестве таблиц.** Микросервис – это представление данных, которыми он управляет. Если вы обнаружите, что микросервис манипулирует данными в нескольких таблицах, или обращаетесь к таблицам за пределами своей базы данных, то это явный признак того, что служба слишком велика. Мы в своей практике пользуемся простым правилом: микросервис должен управлять не более чем тремя-пятью таблицами. Если таблиц больше, то, скорее всего, служба имеет слишком широкий круг обязанностей;
- **службу со слишком большим количеством тестов.** Службы имеют свойство разрастаться со временем. Если первоначально для вашей службы имелось небольшое количество модульных и интеграционных тестов, которое постепенно достигло нескольких сотен, то вам может потребоваться выполнить рефакторинг.


А что можно сказать о слишком мелких микросервисах?
- **Микросервисы, принадлежащие одной части предметной области, размножились как кролики.** При дроблении предметной области на слишком мелкие микросервисы становится очень сложно организовать бизнес-логику. Это связано со стремительным ростом количества служб, необходимых для выполнения работы. Типичный признак – наличие в приложении десятков микросервисов, каждый из которых взаимодействует только с одной таблицей в базе данных.
- **Микросервисы сильно зависят друг от друга.** Микросервисы в одной части предметной области часто обращаться друг к другу, чтобы обработать один пользовательский запрос.
- **Микросервисы становятся набором простых служб CRUD (Create, Replace, Update, Delete – создание, замена, обновление, удаление).** Микросервисы – это выражение бизнес-логики, а не слой абстракции над вашими источниками данных. Если микросервисы не выполняют ничего, кроме логики, связанной с CRUD, то они, вероятно, слишком мелкие.


Архитектура микросервисов должна развиваться эволюционно, и важно понимать, что получить правильную архитектуру с первого раза не получится. Именно поэтому лучше начинать с создания более широких служб.

Также важно избегать категоричности при проектировании. При создании служб иногда можно столкнуться с физическими ограничениями.

Например, вам может понадобиться создать укрупненную службу, объединяющую данные, потому что две отдельные службы будут слишком часто взаимодействовать друг с другом или потому что между разделами предметной области, которые представляют эти службы, не существует четких границ.

В конце концов, будьте прагматичными и не тратьте время на то, чтобы довести архитектуру до совершенства, по прошествии которого вам фактически нечем будет оправдать свои усилия.


### Определение интерфейсов служб

Последняя задача архитектора – определение правил взаимодействий микросервисов друг с другом.

Интерфейсы служб должны быть простыми и очевидными, а разработчики должны представлять общую картину работы всех служб в приложении и полностью понимать работу одной или двух служб.

Вот несколько общих рекомендаций по определению интерфейсов служб.

**Возьмите на вооружение философию REST.** Это одна из лучших практик, наряду с [[♻️ 10.1. Модель зрелости Ричардсона]]. Для взаимодействий между службами философия REST предлагает использовать протокол HTTP с его стандартными глаголами (GET, PUT, POST и DELETE). Моделируйте базовое поведение своих служб, опираясь на эти HTTP-глаголы.

**Используйте URI для обозначения намерений.** URI, выступающие в роли конечных точек службы, должны описывать различные ресурсы в вашей предметной области и служить механизмом отношений между этими ресурсами.

**Используйте JSON для оформления запросов и ответов.** JSON – это чрезвычайно легковесный протокол сериализации данных, и он гораздо проще в использовании, чем XML.

**Используйте коды состояния HTTP для передачи результатов.** Протокол HTTP имеет обширный набор стандартных кодов состояния, указывающих на успех или ошибку. Изучите эти коды и, что особенно важно, используйте их единообразно во всех своих службах.

Все эти базовые рекомендации сходятся к одному: сделайте интерфейсы служб простыми для понимания и использования.

Интерфейсы должны быть определены так, чтобы разработчик сел, посмотрел на них и тут же начал их использовать.

Если интерфейс микросервиса сложен в использовании, то разработчики приложат все силы, чтобы обойти его и разрушить замысел архитектуры.

