
Для создания законченного приложения требуются не только технические специалисты, поэтому мы считаем, что основа успешной разработки микросервисов начинается с вовлечения в процесс трех важнейших ролей:

- **архитектора** – видит общую картину, разбивает приложение на отдельные микросервисы, а затем определяет, как микросервисы будут взаимодействовать друг с другом для получения решения;
- **программиста** – пишет код и определяет, как использовать язык и фреймворки для создания микросервиса;
- **инженера DevOps** – определяет порядок развертывания служб и управления ими в промышленном и непромышленном окружениях. Девиз инженера DevOps: «Последовательность и повторяемость в любом окружении».


---

## Точка зрения архитектора: проектирование микросервисной архитектуры

Роль архитектора в проекте программного обеспечения – предложить рабочую модель задачи, которую нужно решить.

Архитектор формирует основу, на которой разработчики будут строить свой код и приводить в соответствие все части приложения.

При создании микросервисов архитектор проекта фокусируется на трех ключевых задачах:
- [[#Декомпозиция бизнес-задачи]]
- [[#Детализация служб]]
- [[#Определение интерфейсов служб]]

### Декомпозиция бизнес-задачи

Большинство людей, столкнувшись со сложностями, пытаются разбить задачу, над которой они работают, на более простые подзадачи, чтобы не забивать голову множеством мелких деталей.

Они разбивают задачу на несколько основных частей, а затем определяют отношения, существующие между этими частями.

Архитектор разбивает бизнес-задачу на части, представляющие отдельные виды деятельности.

Эти части инкапсулируют **бизнес-правила** и **логику данных**, связанную с определенной частью предметной области.

Например, архитектор может взглянуть на бизнес-поток, который необходимо реализовать, и понять, что ему нужна информация как о покупателе, так и о продукте.

> Наличие двух отдельных видов данных является хорошим признаком того, что в игре может участвовать несколько микросервисов. Правила взаимодействий двух разных частей бизнес-транзакции обычно становятся служебным интерфейсом микросервиса.

Разбиение предметной области – это больше искусство, чем точная наука. Для выявления и выделения кандидатов на создание микросервисов можно использовать следующие рекомендации:

**Опишите бизнес-задачу и обратите внимание на существительные, которые вы используете.** Многократное использование одних и тех же существительных при описании задачи обычно является хорошим признаком некоторой подзадачи, которую можно организовать в виде отдельного микросервиса. Примерами таких существительных для приложения могут быть контракт, лицензии и активы.

**Обратите внимание на глаголы.** Глаголы выделяют действия и часто отмечают естественные контуры предметной области. Если вы обнаружите, что говорите: «Транзакция X должна получить данные от объектов A и B», – то это обычно указывает на присутствие в игре нескольких служб.

**Ищите тесно связанные данные.** Разбивая бизнес-задачу на отдельные части, ищите фрагменты данных, тесно связанные друг с другом. Если вдруг в процессе обсуждения обнаруживается необходимость чтения или обновления данных, которые радикально отличаются от того, что вы обсуждали, то это может указывать на еще одного кандидата в микросервисы. Микросервисы должны владеть только своими данными.


### Детализация служб

Чтобы выделить службы, опираясь на модель данных, недостаточно просто переупаковать код в отдельные проекты.

Необходимо также выделить таблицы в базе данных, к которым будут обращаться службы, и разрешить каждой службе обращаться только к своим конкретным таблицам.

На рисунке ниже показано, как код приложения и модель данных «разбиваются» на отдельные части.

> На рисунке созданы отдельные базы данных для каждой службы, но можно организовать совместное использование общей базы данных.

![Детализация служб](assets/Microservices/detail_sluzhba.png)

Вопрос детализации очень важен при создании микросервисной архитектуры. Основные концепции, которые помогут подобрать правильную степень детализации:

**Лучше сначала создать микросервис с широкой областью охвата, а затем выполнить рефакторинг и разбить его на более мелкие службы.** Вступая на путь создания микросервисов, легко переборщить и превратить в микросервисы все и вся. Однако разделение предметной области на большое количество мелких служб часто приводит к избыточной сложности, потому что микросервисы превращаются в службы, управляющие мелкими фрагментами данных.

**В первую очередь сосредоточьтесь на взаимодействиях служб.** Это поможет определить общие интерфейсы в предметной области. Слишком широкие службы проще реорганизовать, чем слишком мелкие.

**Круг обязанностей служб меняется с развитием нашего понимания предметной области.** Часто с появлением необходимости внедрения новых возможностей в приложение круг обязанностей микросервиса расширяется. То, что сначала было небольшим микросервисом, может разделиться на несколько служб, при этом исходный микросервис превращается в уровень оркестровки новых служб и инкапсулирует их функциональные возможности.


Если микросервис получился слишком большой, то вы, скорее всего, увидите:
- **службу со слишком широким кругом обязанностей.** Общий поток бизнес-логики в службе выглядит сложным и требует применения чрезмерно разнообразного набора правил;
- **службу, которая управляет данными в большом количестве таблиц.** Микросервис – это представление данных, которыми он управляет. Если вы обнаружите, что микросервис манипулирует данными в нескольких таблицах, или обращаетесь к таблицам за пределами своей базы данных, то это явный признак того, что служба слишком велика. Мы в своей практике пользуемся простым правилом: микросервис должен управлять не более чем тремя-пятью таблицами. Если таблиц больше, то, скорее всего, служба имеет слишком широкий круг обязанностей;
- **службу со слишком большим количеством тестов.** Службы имеют свойство разрастаться со временем. Если первоначально для вашей службы имелось небольшое количество модульных и интеграционных тестов, которое постепенно достигло нескольких сотен, то вам может потребоваться выполнить рефакторинг.


А что можно сказать о слишком мелких микросервисах?
- **Микросервисы, принадлежащие одной части предметной области, размножились как кролики.** При дроблении предметной области на слишком мелкие микросервисы становится очень сложно организовать бизнес-логику. Это связано со стремительным ростом количества служб, необходимых для выполнения работы. Типичный признак – наличие в приложении десятков микросервисов, каждый из которых взаимодействует только с одной таблицей в базе данных.
- **Микросервисы сильно зависят друг от друга.** Микросервисы в одной части предметной области часто обращаться друг к другу, чтобы обработать один пользовательский запрос.
- **Микросервисы становятся набором простых служб CRUD (Create, Replace, Update, Delete – создание, замена, обновление, удаление).** Микросервисы – это выражение бизнес-логики, а не слой абстракции над вашими источниками данных. Если микросервисы не выполняют ничего, кроме логики, связанной с CRUD, то они, вероятно, слишком мелкие.


Архитектура микросервисов должна развиваться эволюционно, и важно понимать, что получить правильную архитектуру с первого раза не получится. Именно поэтому лучше начинать с создания более широких служб.

Также важно избегать категоричности при проектировании. При создании служб иногда можно столкнуться с физическими ограничениями.

Например, вам может понадобиться создать укрупненную службу, объединяющую данные, потому что две отдельные службы будут слишком часто взаимодействовать друг с другом или потому что между разделами предметной области, которые представляют эти службы, не существует четких границ.

В конце концов, будьте прагматичными и не тратьте время на то, чтобы довести архитектуру до совершенства, по прошествии которого вам фактически нечем будет оправдать свои усилия.


### Определение интерфейсов служб

Последняя задача архитектора – определение правил взаимодействий микросервисов друг с другом.

Интерфейсы служб должны быть простыми и очевидными, а разработчики должны представлять общую картину работы всех служб в приложении и полностью понимать работу одной или двух служб.

Вот несколько общих рекомендаций по определению интерфейсов служб.

**Возьмите на вооружение философию REST.** Это одна из лучших практик, наряду с [[♻️ 10.1. Модель зрелости Ричардсона]]. Для взаимодействий между службами философия REST предлагает использовать протокол HTTP с его стандартными глаголами (GET, PUT, POST и DELETE). Моделируйте базовое поведение своих служб, опираясь на эти HTTP-глаголы.

**Используйте URI для обозначения намерений.** URI, выступающие в роли конечных точек службы, должны описывать различные ресурсы в вашей предметной области и служить механизмом отношений между этими ресурсами.

**Используйте JSON для оформления запросов и ответов.** JSON – это чрезвычайно легковесный протокол сериализации данных, и он гораздо проще в использовании, чем XML.

**Используйте коды состояния HTTP для передачи результатов.** Протокол HTTP имеет обширный набор стандартных кодов состояния, указывающих на успех или ошибку. Изучите эти коды и, что особенно важно, используйте их единообразно во всех своих службах.

Все эти базовые рекомендации сходятся к одному: сделайте интерфейсы служб простыми для понимания и использования.

Интерфейсы должны быть определены так, чтобы разработчик сел, посмотрел на них и тут же начал их использовать.

Если интерфейс микросервиса сложен в использовании, то разработчики приложат все силы, чтобы обойти его и разрушить замысел архитектуры.


---

## Точка зрения инженера DevOps: сборка выполняемых артефактов

Задача инженера DevOps при работе с микросервисом заключается в управлении службой после того, как она будет передана в эксплуатацию.

Разработка программного кода часто оказывается самой простой частью.

Поддерживать этот код в работоспособном состоянии сложнее.

Четыре принципа DevOps, которые часто используются:

- **Микросервис должен быть автономным.** Он должен поддерживать возможность независимого развертывания нескольких экземпляров, которые запускаются и останавливаются как единственный программный артефакт.
- **Микросервис должен быть настраиваемым.** В момент запуска экземпляр службы должен читать данные, необходимые для настройки, из центрального хранилища или из переданных окружения. Настройка службы не должна требовать вмешательства человека.
- **Доступ к экземпляру микросервиса должен быть прозрачным для клиента.** Клиент не должен знать точное местонахождение службы. Доступ ко всем службам должен осуществляться через агента обнаружения служб. Это позволяет приложению находить экземпляры микросервисов, не зная их физического местоположения.
- **Микросервис должен сообщать о своем состоянии.** Это важная черта облачной архитектуры. Экземпляры микросервисов обязательно будут выходить из строя, и агенты обнаружения должны иметь возможность направлять запросы в обход неисправных экземпляров. Для мониторинга состояния каждого микросервиса Java используется Spring Boot Actuator.

Эти четыре принципа раскрывают парадокс разработки микросервисов.

Микросервисы меньше по размеру и масштабу, но при их использовании в приложении образуется больше движущихся частей, потому что микросервисы распределяются и запускаются независимо друг от друга в своих собственных контейнерах.

Это влечет необходимость иметь более высокий уровень координации, потому что в приложении появляется больше точек отказа.

С точки зрения DevOps мы должны заранее удовлетворить требования микросервисов к техническому и технологическому оснащению и преобразовать эти четыре принципа в стандартный набор событий жизненного цикла, начинающегося после создания и развертывания микросервиса.

Эти четыре принципа можно представить в виде четырех этапов.

На рисунке ниже показано, как эти четыре этапа сочетаются друг с другом.

![Детализация служб](assets/Microservices/devops.png)

**Сборка службы.** На этом этапе осуществляется упаковка и развертывание службы. Этот этап должен гарантировать повторяемость и согласованность процесса, чтобы один и тот же код и среда времени выполнения развертывались одинаково.

**Инициализация службы.** На этом этапе производится настройка службы. Конфигурации приложения и окружения должны отделяться от выполняемого кода, чтобы позволить быстро развернуть и запустить экземпляр микросервиса в любом окружении без вмешательства человека.

**Регистрация/обнаружение службы.** На этом этапе происходит регистрация нового экземпляра микросервиса после развертывания и инициализации, чтобы сделать его доступным для обнаружения другими клиентами приложения.

**Мониторинг службы.** В облачном окружении обычно действует несколько экземпляров одной и той же службы согласно требованиям высокой доступности. С точки зрения DevOps мы должны осуществлять мониторинг экземпляров микросервисов и гарантировать маршрутизацию в обход любых отказавших экземпляров и их остановку.


### Сборка службы: упаковка и развертывание микросервисов

С точки зрения DevOps одним из ключевых требований к микросервисной архитектуре является возможность быстрого развертывания нескольких экземпляров микросервиса в ответ на изменившиеся условия (например, внезапный приток пользователей, проблемы в инфраструктуре и т. д.).

Для этого микросервис должен быть упакован в единый артефакт со всеми его зависимостями.

В число этих зависимостей также должна входить среда времени выполнения (например, HTTP-сервер или контейнер приложения), в которой размещается микросервис.

Процесс компиляции, упаковки и развертывания называется сборкой (assembly).

На рисунке ниже показаны дополнительные сведения об этом этапе:

![Детализация служб](assets/Microservices/assembly.png)

К счастью, почти все фреймворки для разработки микросервисов на Java включают среду времени выполнения, которую можно упаковать и развернуть вместе с кодом.

Например, как показано на рис. 3.10, Maven и Spring Boot создают выполняемый файл JAR, включающий среду времени выполнения, такую как Tomcat.

Команда в следующем примере упаковывает службу лицензий в выполняемый файл JAR, а затем запускает его:

```bash
mvn clean package && java -jar target/licensing-service-0.0.1-SNAPSHOT.jar
```

Для некоторых инженеров DevOps концепция встраивания среды времени выполнения прямо в файл JAR является серьезным сдвигом в их взглядах на развертывание приложений.

Обычные веб-приложения на Java развертываются на сервере приложений.

Эта модель подразумевает, что сервер приложений является самостоятельной сущностью и часто управляется группой системных администраторов, контролирующих конфигурацию сервера независимо от приложений, которые на этом сервере развертываются.

Такое разделение конфигурации сервера и приложений приводит к появлению точек отказа в процессе развертывания.

Это связано с тем, что во многих организациях конфигурация серверов приложений не хранится в системе управления версиями и управляется с помощью комбинации пользовательского интерфейса и отдельных сценариев администрирования.

В таких случаях слишком высока вероятность просачивания дрейфа конфигурации в окружение сервера приложений и вызвать случайное на первый взгляд отключение.


### Инициализация службы: управление конфигурацией микросервисов

Инициализация службы (этап 2) выполняется при запуске микросервиса, когда ему требуется загрузить информацию о конфигурации.

На рисунке ниже представлено более подробное описание процесса инициализации.

![Детализация служб](assets/Microservices/init.png)

Любой разработчик знает, что иногда бывает желательно настроить поведение приложения во время выполнения.

Обычно этот процесс включает чтение конфигурации из файла свойств, развернутого вместе с приложением, или из хранилища, такого как реляционная база данных.

Микросервисы часто сталкиваются с похожими требованиями. Разница в том, что в приложении с микросервисной архитектурой, работающем в облаке, могут быть запущены сотни или даже тысячи экземпляров одного и того же микросервиса.

Более того, службы могут быть распределены по всему миру. При большом количестве географически распределенных служб становится невозможно повторно развернуть службы, чтобы они прочитали обновленную конфигурацию.

Хранение данных во внешнем хранилище решает эту проблему.

**Но микросервисы в облаке привносят ряд дополнительных сложностей:**
- Конфигурации обычно имеют простую структуру, часто читаются и редко записываются. В этой ситуации реляционные базы данных избыточны, потому что они предназначены для управления гораздо более сложными моделями данных, чем простой набор пар ключ/значение.
- Данные с информацией о конфигурации часто читаются, но редко меняются, поэтому они должны обеспечивать минимальную задержку для чтения.
- Хранилище должно быть высокодоступным и находиться рядом со службами, читающими свои конфигурации из этого хранилища. Хранилище с конфигурациями не может выйти из строя полностью, иначе оно станет единственной точкой отказа для вашего приложения.


### Регистрация и обнаружение службы: взаимодействие клиентов с микросервисами

С точки зрения клиента доступ к микросервису должен быть прозрачным и не зависеть от его физического местоположения, потому что серверы в облачном окружении **эфемерны**.

Эфемерность означает, что серверы, где размещена служба, обычно имеют более **короткий жизненный цикл**, чем жизненный цикл службы, работающей в корпоративном центре обработки данных.

Облачные службы можно останавливать и быстро запускать на серверах с совершенно другими IP-адресами.

Настаивая на том, что службы должны рассматриваться как недолговечные одноразовые объекты, микросервисные архитектуры позволяют достичь высокой степени масштабируемости и доступности за счет запуска нескольких экземпляров службы.

Масштабом и отказоустойчивостью можно управлять так быстро, как того требует ситуация.

Каждой службе назначается уникальный и непостоянный IP-адрес.

Обратной стороной эфемерных служб является невозможность вручную управлять большим пулом постоянно появляющихся и исчезающих экземпляров этих служб.

Экземпляр микросервиса должен зарегистрироваться в стороннем агенте, который называют **агентом обнаружения служб** .

Когда экземпляр микросервиса регистрируется в агенте обнаружения служб, он сообщает агенту свой физический IP-адрес (или доменный адрес) и логическое имя, которое приложение может использовать для поиска службы.

Некоторые агенты обнаружения служб также требуют указывать URL, который они смогут затем использовать для выполнения проверок работоспособности зарегистрировавшихся служб.

В таком сценарии клиент обращается к агенту обнаружения, чтобы узнать местоположение службы.

![Детализация служб](assets/Microservices/service_register.png)


### Мониторинг состояния микросервиса

Агент обнаружения службы действует не только как регулировщик, направляющий клиентов к тем или иным службам.

В облачных приложениях с микросервисной архитектурой часто одновременно действует несколько экземпляров службы.

Рано или поздно один из этих экземпляров обязательно потерпит сбой.

Агент обнаружения служб наблюдает за работоспособностью каждого зарегистрированного экземпляра и удаляет все отказавшие экземпляры из своих таблиц маршрутизации, чтобы гарантировать, что клиенты не будут отправлены к отказавшему экземпляру.

После запуска микросервиса агент обнаружения служб продолжит наблюдать за ним и проверять связь с его интерфейсом проверки работоспособности, чтобы убедиться, что служба доступна.

![Детализация служб](assets/Microservices/monitoring.png)

После создания согласованного интерфейса проверки работоспособности можно использовать облачные инструменты мониторинга для обнаружения проблем и реагирования на них.

Если агент обнаружения служб выявляет проблему с экземпляром службы, он может, например, остановить отказавший экземпляр или запустить дополнительные экземпляры службы.

Самый простой способ создать интерфейс проверки работоспособности в окружении микросервисов – реализовать конечную точку HTTP, возвращающую данные в формате JSON и код состояния HTTP.

В микросервисах, не основанных на Spring Boot, разработчик часто обязан написать конечную точку, которая информацию о работоспособности службы.

В Spring Boot такие конечные точки реализуются тривиально просто, достаточно лишь изменить файл сборки Maven и подключить модуль **Spring Actuator**.

Spring Actuator предоставляет готовые конечные точки, которые помогут вам проверять работоспособность вашей службы и управлять ею.


---

## Объединение точек зрения

Облачные микросервисы кажутся простыми, но эта простота обманчива.

Чтобы добиться успеха с ними, нужно иметь целостное представление, объединяющее точки зрения архитектора, разработчика и инженера DevOps.

Вот ключевые выводы по каждой из этих точек зрения.

### Архитектор

Сосредоточьтесь на естественных контурах вашей бизнес-задачи.

Опишите предметную область, озвучьте получившееся описание и послушайте самого себя.

Входе этого процесса вы непременно выявите кандидатов на микросервисы.

Помните также, что лучше начать с больших микросервисов и позднее выполнить рефакторинг, разбив крупные микросервисы на более мелкие, чем с большого количества небольших микросервисов.

Хорошие микросервисные архитектуры не появляются в одночасье и требуют постепенной проработки.


### Инженер-программист (он же разработчик)

Небольшой размер службы не означает, что базовые принципы проектирования можно выбросить в утиль.

Сосредоточьтесь на создании многоуровневой службы, каждый уровень которой имеет свой круг обязанностей.

Избегайте соблазна создавать фреймворки в своем коде и постарайтесь сделать каждый микросервис полностью независимым.

Преждевременное проектирование и внедрение фреймворков может повлечь огромные затраты на обслуживание позднее.


### Инженер DevOps

Службы существуют не в вакууме.

С самого начала определите, как должен выглядеть жизненный цикл ваших служб.

Внимание инженера DevOps должно быть сосредоточено не только на автоматизации сборки и развертывания службы, но также на мониторинге ее работоспособности и действиях, которые должны выполняться, когда что-то пойдет не так.

Ввод в эксплуатацию службы часто требует больше работы и предусмотрительности, чем написание бизнес-логики.

