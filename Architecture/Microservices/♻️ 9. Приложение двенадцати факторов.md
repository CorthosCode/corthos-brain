
Для решения проблем, сопутствующих созданию облачных микросервисов, используется (иногда) руководство с названием «Приложение двенадцати факторов» (https://12factor.net/ru/), разработанное в компании Heroku.

Это приложение помогает создавать и развивать облачные приложения (микросервисы). 

Можно рассматривать эту методологию как набор практик разработки и проектирования, которые сосредоточены на динамическом масштабировании и фундаментальных аспектах, присущих распределенным службам.

Эта методология была создана в 2002 году несколькими разработчиками Heroku. 

Основная цель состояла в том, чтобы определить 12 лучших практик проектирования микросервисов.

Это руководство не только определяет наиболее распространенные проблемы, встречающиеся при разработке современных приложений, но и предлагает надежные решения.

Методы, описанные в руководстве «Приложение двенадцати факторов», показаны на рисунке ниже.

![Приложение 12 факторов](assets/Microservices/12_factors.png)


[[#1. База кода]]
[[#2. Зависимости]]
[[#3. Конфигурация]]
[[#3. Конфигурация]]
[[#4. Вспомогательные службы]]
[[#5. Сборка, выпуск, выполнение]]
[[#6. Процессы]]
[[#7. Привязка портов]]
[[#8. Масштабируемость]]
[[#9. Одноразовость]]
[[#10. Сходство окружений разработки/эксплуатации]]
[[#11. Журналирование]]
[[#12. Задача администрирования]]


---

## 1. База кода

В соответствии с этой практикой каждый микросервис должен иметь свою отдельную базу исходного кода.

Кроме того, важно подчеркнуть, что информация о конфигурации сервера также должна находиться в системе управления версиями.

Помните, что управление версиями – это управление изменениями в файлах или в наборе файлов.

База кода может включать несколько экземпляров окружений развертывания (таких как окружение разработки, окружение тестирования, промышленное окружение и т. д.), но не имеет общих компонентов с другими микросервисами.

Это важный ориентир, потому что если мы будем использовать общую базу кода для всех микросервисов, то в конечном итоге создадим множество неизменяемых выпусков, принадлежащих разным окружениям.

На рисунке ниже показана отдельная база кода с множеством окружений развертывания.

![База кода](assets/Microservices/code_base.png)


---

## 2. Зависимости

Эта практика требует явно объявлять и изолировать зависимости вашего приложения, используя инструменты сборки, такие как Maven или Gradle (Java).

Зависимости от сторонних JAR должны объявляться с указанием конкретных номеров версий этих артефактов.

Это позволит создавать микросервисы всегда с одной и той же версией библиотеки.

Если вы плохо знакомы с концепцией инструментов сборки, то взгляните на рисунок ниже, который поможет вам понять, как работает инструмент сборки.

Сначала Maven читает зависимости из файла pom. xml, а затем отыскивает их в локальном репозитории.

Отсутствующие зависимости загружаются из центрального репозитория Maven и добавляются в локальный репозиторий для использования в будущем.

![Зависимости](assets/Microservices/dependencies.png)


---

## 3. Конфигурация

Эта практика относится к хранению конфигураций приложения (особенно конфигураций, зависящих от окружения).

Никогда не добавляйте конфигурации в исходный код! Полностью отделяйте конфигурацию от развертываемого микросервиса.

Представьте такой сценарий: вы хотите обновить конфигурацию для микросервиса, 100 экземпляров которого было запущено на сервере. Если конфигурация будет храниться в исходном коде микросервиса, то после внесения изменений в конфигурацию вам придется повторно развернуть все 100 экземпляров. Однако в микросервисе можно реализовать загрузку внешней конфигурации и использовать возможности облака для повторной загрузки конфигурации во время выполнения без перезапуска микросервиса. На рисунке ниже показан пример, как должно выглядеть ваше окружение.

![Зависимости](assets/Microservices/configuration.png)


---

## 4. Вспомогательные службы

Микросервисы часто обмениваются данными по сети с базами данных, службами RESTful, другими серверами или системами обмена сообщениями.

В таких случаях вы должны гарантировать возможность замены локальных служб сторонними без каких-либо изменений в коде приложения.

На рисунке ниже показан пример некоторых вспомогательных служб, которые могут использовать приложения.

![Зависимости](assets/Microservices/other_services.png)


---

## 5. Сборка, выпуск, выполнение

Эта практика напоминает о необходимости четкого разделения этапов сборки, выпуска и выполнения приложения.

Микросервисы не должны зависеть от окружения, в котором они выполняются.

Любые изменения в окружении, произведенные после сборки кода, должны приводить к повторению процессов сборки и развертывания.

Скомпилированная служба считается зафиксированной и не может быть изменена.

Этап выпуска отвечает за объединение скомпилированной службы с определенной конфигурацией для каждого целевого окружения.

Если не разделить разные этапы, то это может привести к проблемам и расхождениям в коде, которые невозможно или – в лучшем случае – трудно отследить.

Например, если изменить службу, уже развернутую в промышленном окружении, то изменения не будут зафиксированы в репозитории, и могут возникнуть две ситуации: изменения потеряются в следующих версиях службы или вам придется копировать изменения в новую версию.

На рисунке ниже показан пример архитектуры, соответствующей этой практике.

![Зависимости](assets/Microservices/build_delivery_run.png)


---

## 6. Процессы

Микросервисы не должны иметь состояния и хранить только информацию, необходимую для выполнения запрошенной транзакции.

Микросервисы могут быть остановлены в любой момент, и потеря экземпляра службы не должна приводить к потере данных.

Если состояние все же необходимо, то оно должно храниться в кеше, таком как Redis, или во внутренней базе данных.

На рисунке ниже показано, как работают микросервисы без состояния.

![Зависимости](assets/Microservices/processes.png)


---

## 7. Привязка портов

Под привязкой портов подразумевается экспортирование служб через определенные порты.

В микросервисной архитектуре микросервисы полностью автономны, и каждый имеет свой механизм времени выполнения, упакованный в выполняемый файл вместе с кодом службы.

Служба не должна нуждаться в отдельном веб-сервере или сервере приложений и должна поддерживать возможность запуска из командной строки и непосредственного подключения к ней через открытый порт HTTP.


---

## 8. Масштабируемость

Согласно практике масштабируемости облачные приложения должны масштабироваться **по горизонтали** с использованием модели процессов.

Что это значит? Это значит, что должна иметься возможность вместо одного процесса запустить несколько процессов, чтобы потом распределить нагрузку между ними.

Под **вертикальным масштабированием** подразумевается увеличение мощности аппаратной инфраструктуры (процессор, объем ОЗУ), а под **горизонтальным** – запуск дополнительных экземпляров приложения.

В ситуациях, когда возникает потребность в масштабировании, запускайте больше экземпляров микросервисов и выполняйте горизонтальное масштабирование, а не вертикальное.

На рисунке ниже показана разница между этими типами масштабирования.

![Зависимости](assets/Microservices/vertical_horizontal.png)


---

## 9. Одноразовость

Микросервисы должны быть одноразовыми и запускаться и останавливаться по запросу, чтобы упростить эластичное масштабирование и быстрое развертывание приложения и изменений в конфигурации.

В идеале запуск должен длиться не дольше пары секунд с момента команды запуска до момента, когда процесс будет готов принимать запросы.

Под одноразовостью мы подразумеваем возможность удаления отказавших экземпляров и запуск новых без влияния на другие службы.

Например, если один из экземпляров микросервиса выйдет из строя из-за сбоя в оборудовании, мы можем остановить этот экземпляр, не затрагивая другие микросервисы, и при необходимости запустить другой экземпляр в другом месте.


---

## 10. Сходство окружений разработки/эксплуатации

Эта практика требует обеспечить максимальное сходство разных окружений (например, разработки, тестирования, промышленной эксплуатации).

Окружения всегда должны содержать похожие версии развернутого кода, инфраструктуры и служб.

Этого можно добиться с помощью непрерывного развертывания, которое максимально автоматизирует процесс развертывания, позволяя развертывать микросервисы в нескольких окружениях за короткое время.

После отправки в репозиторий код следует протестировать, а затем как можно быстрее передать из окружения разработки в промышленное окружение.

Это особенно важно для тех, кто стремится избежать ошибок развертывания.

Сходство окружений разработки и промышленной эксплуатации позволяет контролировать все возможные сценарии, которые могут возникнуть при развертывании и выполнении приложения.


---

## 11. Журналирование

Журналы – это поток событий.

Журналы должны управляться такими инструментами, как Logstash (https://www.elastic.co/logstash) или Fluentd (https://www.fluentd.org/), которые собирают и хранят журналы в централизованном хранилище.

Микросервис никогда не должен заботиться о том, как это происходит.

От него требуется только выводить журналируемую информацию в стандартный вывод (stdout).

На рисунке ниже показано, как осуществляется журналирование в микросервисной архитектуре, использующей этот стек.

![Зависимости](assets/Microservices/logging.png)


---

## 12. Задача администрирования

Разработчикам часто приходится выполнять задачи администрирования своих служб (например, переносить или преобразовывать данные).

Такие задачи не должны быть уникальными и всегда выполняться только с помощью сценариев, которые хранятся и обслуживаются через репозиторий исходного кода.

Сценарии должны быть повторяемыми и неизменяемыми (т. е. код сценария не должен изменяться) в каждом окружении.

Важно определить типы задач, которые должны выполняться при запуске микросервиса, чтобы при наличии нескольких микросервисов с такими сценариями мы могли выполнять все задачи администрирования без любых манипуляций вручную.

