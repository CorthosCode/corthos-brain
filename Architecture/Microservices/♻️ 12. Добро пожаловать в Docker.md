
При создание микросервисов, необходимо решить проблему переносимости и определить, как запускать микросервисы в различных технологических окружениях?

**Переносимость** – это возможность использовать программное обеспечение в разных окружениях.

В последние годы контейнеры приобретают все большую популярность, превращаясь из «полезной» в «обязательную» программную архитектуру.

Контейнеры предлагают гибкий и удобный способ переноса и выполнения любого программного обеспечения с одной платформы на другую (например, с машины разработчика на физический или виртуальный корпоративный сервер).

Мы можем заменить традиционные модели веб-серверов меньшими и гораздо более гибкими виртуализированными программными контейнерами, обладающими такими преимуществами, как скорость, переносимость и масштабируемость.


---

## Контейнеры или виртуальные машины?

Во многих компаниях виртуальные машины (ВМ) продолжают оставаться стандартом де-факто для развертывания программного обеспечения.

**ВМ** – это программная среда, имитирующая работу одного компьютера на другом компьютере. Виртуальные машины основаны на гипервизоре, имитирующем всю физическую машину и выделяющем желаемый объем системной памяти, ядер процессора, дискового хранилища и других ресурсов.

С другой стороны, **контейнер** – это пакет, содержащий виртуальную операционную систему (ОС) и позволяющий запускать приложения с их зависимостями в изолированном и независимом окружении.

Обе технологии имеют некоторое сходство, например наличие гипервизора или механизма управления контейнерами, обеспечивающего работу технологии, но способ их реализации делает виртуальные машины и контейнеры очень разными.

На рисунке ниже показаны самые основные различия между виртуальными машинами и контейнерами.

![Контейнеры или ВМ](assets/Microservices/vm_vs_container.png)

После беглого взгляда на рисунке может показаться, что между виртуальными машинами и контейнерами нет большой разницы.

В конце концов, контейнеры на этом рисунке отличаются только отсутствием уровня гостевой ОС, а гипервизор заменил механизм управления контейнерами.

Однако различия между виртуальными машинами и контейнерами огромны.

При создании виртуальной машины мы должны заранее определить, сколько физических ресурсов понадобится, например количество виртуальных процессоров или объем ОЗУ и дискового пространства. Выяснение этих значений может быть сложной задачей, решая которую следует учитывать следующее:
- процессоры могут совместно использоваться несколькими виртуальными машинами;
- дисковое пространство, доступное виртуальной машине, можно ограничить ее потребностями. Вы можете задать максимальный размер диска, но активно будет использоваться только некоторая его часть;
- память, зарезервированная за одной виртуальной машиной, не может использоваться другими виртуальными машинами.

При использовании контейнеров тоже можно ограничить объем памяти и количество процессоров, доступных контейнеру, например, с помощью Kubernetes, но это не обязательно.

Если не задать эти ограничения, то механизм управления контейнерами автоматически выделит необходимые ресурсы для правильной работы контейнера.

Поскольку контейнерам не нужна отдельная ОС, это снижает нагрузку на физическую машину, а также уменьшает потребность в памяти и сокращает время запуска приложения.

То есть контейнеры намного легче виртуальных машин.

Наконец, обе технологии имеют свои достоинства и недостатки, и выбор между ними зависит от конкретных потребностей.

Например, если требуется использовать несколько операционных систем для запуска разных приложений на одном сервере или если приложение требует функциональных возможностей ОС, то лучшим выбором будут виртуальные машины.

Выбор контейнеров является естественным следствием выбора облачной архитектуры.

Вместо виртуализации оборудования, как в случае с виртуальными машинами, мы будем использовать контейнеры только для виртуализации уровня ОС, что дает нам гораздо более легковесную альтернативу, по сравнению с запуском микросервисов локально или на отдельном экземпляре облачного сервера.

В настоящее время производительность и переносимость являются критически важными характеристиками, влияющими на принятие решений в компаниях.

Поэтому важно знать преимущества технологий:
- контейнеры могут работать повсюду, что упрощает разработку и внедрение, а также увеличивает переносимость;
- контейнеры позволяют создавать предсказуемые окружения, полностью изолированные от других приложений;
- контейнеры запускаются и останавливаются быстрее, чем виртуальные машины, что делает их более пригодными для использования в облаке;
- контейнеры масштабируемы и могут активно использоваться для оптимизации потребления ресурсов, увеличения производительности и удобства обслуживания приложения, работающего внутри контейнера;
- контейнеры позволяют запустить максимальное количество приложений на минимальном количестве серверов.


---

## Что такое Docker?

Docker – это популярный движок контейнеров с открытым исходным кодом на основе Linux, созданный в марте 2013 года Соломоном Хайксом (Solomon Hykes), основателем и генеральным директором dotCloud.

Docker создавался как технология, отвечающая за запуск контейнеров с нашими приложениями внутри и управление ими.

Эта технология позволяет совместно использовать ресурсы физической машины несколькими контейнерами без дополнительных затрат на создание виртуальных машин.

Поддержка Docker со стороны крупных компаний, таких как IBM, Microsoft и Google, позволила превратить новую технологию в фундаментальный инструмент для разработчиков программного обеспечения.

В настоящее время Docker продолжает развиваться и является одним из наиболее широко используемых инструментов для развертывания программного обеспечения в контейнерах на любых серверах.

> Контейнер – это механизм логической упаковки, предоставляющий приложениям все необходимое для работы.

Чтобы лучше понять, как работает Docker, важно отметить, что ядром всей системы Docker является движок **Docker Engine**.

Что такое Docker Engine? Это приложение с архитектурой клиент–сервер. Оно устанавливается на компьютер и состоит из трех важных компонентов: сервера, REST API и интерфейса командной строки (Command-Line Interface, CLI).

Эти и другие компоненты Docker показаны на рисунке ниже.

![Контейнеры или ВМ](assets/Microservices/docker.png)


Docker Engine содержит следующие компоненты:

- **Демон Docker.** Сервер с именем dockerd, который позволяет создавать образы Docker и управлять ими. Интерфейс REST API и клиент командной строки передают инструкции этому демону.
- **Клиент Docker.** Пользователи взаимодействуют с Docker через клиента. Когда пользователь запускает команду Docker, клиент командной строки передает инструкции демону.
- **Реестр Docker.** Место, где хранятся образы Docker. Реестры могут быть общедоступными или частными. По умолчанию общедоступные реестры размещаются на Docker Hub, но также можно создать свой частный реестр.
- **Образы Docker.** Шаблоны, доступные только для чтения, которые содержат инструкции по созданию контейнера Docker. Образы можно получить на Docker Hub и использовать их как есть или изменить и добавить дополнительные инструкции. Также можно создавать новые образы с помощью файла Dockerfile.
- **Контейнеры Docker.** После создания и запуска командой docker run образ Docker создает контейнер. Внутри этого контейнера запускаются приложение и его окружение. Запустить, остановить и удалить контейнер Docker можно с помощью Docker API или интерфейса командной строки Docker CLI.
- **Тома Docker.** Тома Docker – предпочтительный механизм хранения данных, созданных Docker и используемых контейнерами. Ими можно управлять с помощью Docker API или Docker CLI.
- **Сети Docker.** Позволяют подключать контейнеры к сколь угодно большому количеству сетей. Сети можно рассматривать как средство связи с изолированными контейнерами. Docker содержит следующие пять типов сетевых драйверов: bridge, host, overlay, none и macvlan.

На рисунке ниже показана схема работы Docker. Обратите внимание, что демон Docker отвечает за все действия с контейнерами.

Как можно видеть на рисунке, демон получает команды от клиента Docker; эти команды могут отправляться через интерфейс командной строки или REST API.

На схеме также видно, как образы Docker, найденные в реестрах, создают контейнеры.

![Контейнеры или ВМ](assets/Microservices/docker_command.png)


---

## Файлы Dockerfile

Dockerfile – это простой текстовый файл, содержащий список инструкций и команд, которые клиент Docker должен запустить, чтобы создать образ.

Проще говоря, этот файл автоматизирует процесс создания образа.

Команды, используемые в Dockerfile, аналогичны командам Linux, что упрощает изучение файлов Dockerfile.

В таблице ниже перечислены наиболее употребимые команды, которые будут использоваться в ваших файлах Dockerfile.

![Контейнеры или ВМ](assets/Microservices/dockerfile_command.png)


---

## Docker Compose

Docker Compose упрощает использование Docker, позволяя создавать сценарии, которые облегчают проектирование и создание служб.

С помощью Docker Compose можно запускать несколько контейнеров как одну службу или создавать разные контейнеры одновременно.


Пример файла docker-compose.yml:

```yml
version: <docker-compose-version>
services:
	database:
		image: <database-docker-image-name>
		ports:
		- "<databasePort>:<databasePort>"
		environment:
			POSTGRES_USER: <databaseUser>
			POSTGRES_PASSWORD: <databasePassword>
			POSTGRES_DB: <databaseName>
 
	<service-name>:
		image: <service-docker-image-name>
		ports:
		- "<applicationPort>:<applicationPort>"
		environment:
			PROFILE: <profile-name>
			DATABASESERVER_PORT: "<databasePort>"
		container_name: <container_name>
		networks:
			backend:
				aliases:
					- "alias"
networks:
	backend:
driver: bridge
```


Основные инструкции Docker Compose

![Контейнеры или ВМ](assets/Microservices/docker_compose_instruction.png)


Основные команды Docker Compose

![Контейнеры или ВМ](assets/Microservices/docker_compose_command.png)

