
Разработчики программного обеспечения постоянно слышат о важности отделения конфигурации приложения от кода.

В большинстве случаев это означает отказ от использования жестко запрограммированных настроек в коде.

Несоблюдение этого принципа может усложнить дальнейшее развитие приложения, поскольку при каждом изменении конфигурации приходится повторно компилировать и развертывать приложение.

Полное отделение конфигурации от кода приложения позволяет разработчикам и сопровождающим специалистам вносить изменения в конфигурацию без необходимости повторной компиляции.

Но это также влечет дополнительные сложности, потому что у разработчиков появляется еще один артефакт, которым нужно управлять и развертывать вместе с приложением.

Многие разработчики используют файлы свойств (YAML, JSON или XML) для хранения информации о конфигурации.

Хранение настроек приложения в этих файлах – настолько простая задача, что большинство разработчиков не делает ничего, кроме как помещают конфигурационные файлы в систему управления версиями и развертывают эти файлы вместе с приложением.

Этот подход более или менее применим для небольшого количества приложений, но быстро становится непригодным при работе с облачными приложениями, которые могут состоять из сотен микросервисов, каждый из которых может иметь несколько запущенных экземпляров.

Внезапно простой и понятный процесс становится необычайно сложным, и команде разработчиков приходится бороться со всеми этими конфигурационными файлами.

Например, представьте, что у нас есть несколько сотен микросервисов и каждый содержит разные конфигурации для трех окружений.

Если не управлять этими файлами отдельно, то при каждом изменении нам придется отыскать нужный файл в репозитории, проследить за процессом интеграции (если он есть) и перезапустить приложение.

Чтобы избежать этого катастрофического сценария, при разработке облачных микросервисов следует использовать следующие рекомендации:

- **полностью отделяйте конфигурацию** приложения от развертываемого кода;
- **создавайте неизменяемые образы приложений**, которые никогда не меняются по мере продвижения между окружениями;
- **передавайте любую конфигурацию через переменные окружения** или централизованный репозиторий, к которому микросервисы могут обратиться при запуске.


---

## Об управлении конфигурациями (и сложностью)

Управление конфигурацией приложений имеет решающее значение для микросервисов, работающих в облаке, потому что экземпляры микросервисов должны запускаться быстро и с минимальным вмешательством со стороны человека.

Когда человеку приходится вручную настраивать службу или развертывать ее, то возникает вероятность дрейфа конфигурации, неожиданного сбоя и задержки в реагировании на проблемы масштабируемости в приложении.

Четыре принципы, которым необходимо следовать для управления конфигурацией:

- **Отделение.** Мы должны полностью отделить конфигурацию службы от процесса ее развертывания. Конфигурация не должна развертываться вместе с экземпляром службы. Вместо этого информация о конфигурации должна передаваться в переменных окружения или извлекаться из централизованного репозитория в момент запуска службы.
- **Абстрагирование.** Также необходимо абстрагировать доступ к конфигурации с использованием служебного интерфейса. Служба не должна содержать код, который напрямую читает конфигурацию из файлов или базы данных, вместо этого следует использовать REST-службу, возвращающую конфигурацию приложения в формате JSON.
- **Централизация.** Облачное приложение может содержать буквально сотни служб, поэтому очень важно свести к минимуму количество различных репозиториев, используемых для хранения конфигураций. Храните конфигурации своих приложений в как можно меньшем количестве репозиториев.
- **Надежность.** Информация о конфигурации приложения будет полностью отделена от развернутой службы и централизована, поэтому очень важно, чтобы служба, управляющая конфигурациями, была высокодоступной и избыточной.

Важно помнить, что при отделении конфигурации от фактического кода создается внешняя зависимость, которой нужно будет управлять и хранить в системе управления версиями.

Невозможно переоценить то обстоятельство, что конфигурация приложения должна управляться надлежащим образом, потому что неправильно организованное управление конфигурацией является благодатной почвой для трудно обнаруживаемых ошибок и незапланированных отключений.


---

## Архитектура управления конфигурацией

На рисунке ниже более подробно изображен процесс инициализации и показано, насколько важную роль играет служба управления конфигурациями на этом этапе.

![Архитектура управления конфигурацией](assets/Microservices/configuration_architecture.png)

Когда микросервис запускается, он выполняет несколько шагов в начале своего жизненного цикла. Конфигурация приложения извлекается им на этапе инициализации

![Архитектура управления конфигурацией](assets/Microservices/configuration_architecture_2.png)


1. Когда запускается экземпляр микросервиса, он обращается к конечной точке службы для получения своей конфигурации, которая зависит от окружения, в котором запускается микросервис. Информация, необходимая для подключения к службе управления конфигурацией (учетные данные, адрес конечной точки службы и т. д.), передается в микросервис в момент запуска.
2. Фактическая конфигурация хранится в репозитории. В зависимости от реализации репозитория конфигурации можно выбрать разные способы хранения. Это могут быть файлы в системе управления версиями, реляционные базы данных или хранилища данных типа ключ/значение.
3. Фактическое управление конфигурацией приложения осуществляется независимо от развертывания приложения. Изменения в конфигурации обычно передаются через конвейер сборки и развертывания, где эти изменения могут быть отмечены информацией о версии и окружениях, в которых они применяются (разработка, подготовка, производство и т. д.).
4. После изменения конфигурации соответствующие приложения, должны быть уведомлены об этом, чтобы иметь возможность обновить свои настройки.


Решения управления конфигурацией, реализованные в проектах с открытым исходным кодом

| Решение                           | Описание                                                                                                                                                                                       | Характеристики                                                                                                                                                                                                                                                      |
| --------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| etcd                              | Реализовано на Go. Используется для обнаружения служб и в качестве хранилища пар ключ/ значение. Использует протокол raft (https://raft.github.io/) для своей модели распределенных вычислений | Высокая скорость Масштабируемость Управление из командной строки Простота в использовании и настройке                                                                                                                                                               |
| Eureka                            | Написано в компании Netflix. Чрезвычайно надежное. Используется для обнаружения служб и в качестве хранилища пар ключ/значение                                                                 | Распределенное хранилище пар ключ/значение Высокая гибкость, но требует некоторых усилий для настройки Поддерживает динамическое обновление клиентов из коробки                                                                                                     |
| Consul                            | Написано в компании HashiCorp. Похоже на etcd и Eureka, но использует иной алгоритм в модели распределенных вычислений                                                                         | Высокая скорость Предлагает свою поддержку обнаружения служб с возможностью интеграции с DNS Не поддерживает динамическое обновление клиентов из коробки                                                                                                            |
| Zookeeper                         | Проект Apache. Поддерживает распределенные блокировки. Часто используется в качестве решения для управления конфигурацией и в качестве хранилища пар ключ/значение                             | Давнее и хорошо проверенное решение Высокая сложность использования Может применяться для управления конфигурациями, но только если вы уже используете Zookeeper в своей архитектуре                                                                                |
| Spring Cloud Configuration Server | Решение с открытым исходным кодом. Универсальное решение для управления конфигурациями с несколькими базовыми механизмами хранения                                                             | Нераспределенное хранилище пар ключ/значение Предлагает тесную интеграцию со службами, использующими и не использующими Spring Позволяет задействовать несколько базовых механизмов для хранения конфигураций, включая общие файловые системы, Eureka, Consul и Git |


Все решения, перечисленные в таблице, с успехом можно использовать для организации своей архитектуры управления конфигурацией.

- сервер Spring Cloud Configuration Server прост в настройке и использовании;
- Spring Cloud Config тесно интегрируется с Spring Boot – вы можете прочитать конфигурацию вашего приложения с помощью нескольких простых аннотаций;
- Config Server поддерживает несколько механизмов для хранения конфигураций;
- из всех решений, перечисленных в таблице, только Config Server можно напрямую интегрировать с платформами управления версиями Git и HashiCorp Vault.

