
## Использование Spring Cloud Config Server с файловой системой

Пример `application.yml`:

```yml
spring:  
  application:  
    name: "config-service"  
  profiles:  
    active: native  
  cloud:  
    config:  
      server:  
        native:  
          search-locations:  
            file:///{FILE_PATH}
```

> native – это просто профиль, созданный для Spring Cloud Configuration Server, который сообщает, что файлы конфигурации будут извлекаться из пути поиска классов (classpath) или из файловой системы.

Последняя важная деталь – определение каталога, в котором находятся данные приложения. Например:

```yml
server:  
	native:  
		search-locations:  
			file:///Users/illary.huaylupo
```

Одним из важных параметров в настройках является **search-locations**.

Этот параметр содержит список каталогов, разделенных запятыми, для каждого приложения, настройками которых будет управлять Config Server.

В предыдущем примере указан путь в файловой системе (file:///Users/illary.huaylupo), но также можно указать конкретный путь к классам. Вот как это делается:

```yml
server:
	native:
		search-locations: classpath:/config
```

> Атрибут classpath заставляет Spring Cloud Config Server искать файлы в папке src/main/resources/config


---

## Создание конфигурационных файлов для службы

В Spring Cloud Config все основано на **иерархиях**.

Поэтому конфигурация вашего приложения будет определяться **именем приложения** и **названием окружения**, в котором эта конфигурация будет использоваться.

На рисунке ниже показан пример, как будет настраиваться и использоваться служба Spring Cloud Config.

Следует отметить один важный момент: служба Config – это еще один микросервис, работающий в вашем окружении.

После ее настройки содержимое службы будет доступно через конечную точку REST.

В соответствии с соглашениями файлы конфигурации приложения должны иметь имена: **appname-env.properties** или **appname-env.yml**. Также, как показано на рисунке ниже, имена окружений транслируются непосредственно в адреса URL конфигурации.

Когда запускается микросервис, окружение, в котором запускается служба, будет **определяться профилем** Spring Boot, передаваемым в командной строке.

Если профиль не указан в командной строке, то Spring Boot **по умолчанию будет использовать конфигурацию в файле application.properties**, упакованном вместе с приложением.

![Spring Cloud Config](assets/Microservices/spring_cloud_config.png)

При  запросе `curl http://localhost:8080/test-service/default` будут получены данные из проперти файла, объявленного без названия окружения `test-service.properties`

Но если сделать запрос на `curl http://localhost:8080/test-service/default` можно заметить, что при выборе конечной точки dev Spring Cloud Configuration Server вернул не только конфигурацию для окружения разработки, но и конфигурацию с настройками по умолчанию.

```json
{
  "name": "test-service",
  "profiles": [
    "dev"
  ],
  "label": null,
  "version": null,
  "state": null,
  "propertySources": [
    {
      "name": "classpath:/config/test-service-dev.properties",
      "source": {
        "example.property": "I AM DEV",
        "spring.datasource.url": "jdbc:postgresql://localhost:5432/ostock_dev",
        "spring.datasource.username": "postgres",
        "spring.datasource.password": "postgres"
      }
    },
    {
      "name": "classpath:/config/test-service.properties",
      "source": {
        "example.property": "I AM THE DEFAULT",
        "spring.jpa.hibernate.ddl-auto": "none",
        "spring.jpa.database": "POSTGRESQL",
        "spring.datasource.platform": "postgres",
        "spring.jpa.show-sql": "true",
        "spring.jpa.hibernate.naming-strategy": "org.hibernate.cfg.ImprovedNamingStrategy",
        "spring.jpa.properties.hibernate.dialect": "org.hibernate.dialect.PostgreSQLDialect",
        "spring.database.driverClassName": "org.postgresql.Driver",
        "spring.datasource.testWhileIdle": "true",
        "spring.datasource.validationQuery": "SELECT 1",
        "management.endpoints.web.exposure.include": "*",
        "management.endpoints.enabled-by-default": "true"
      }
    }
  ]
}
```


Причина такого поведения Spring Cloud Config в том, что фреймворк Spring реализует **иерархический механизм** решения проблем.

То есть фреймворк Spring сначала ищет свойство, определенное в файле свойств по умолчанию, а затем переопределяет значение по умолчанию значением из файла свойств для заданного окружения, если оно присутствует.

> Однако вы не увидите этого поведения, напрямую вызвав конечную точку REST службы Spring Cloud Config. Конечная точка REST возвращает все значения из конфигурации для заданного окружения и конфигурации по умолчанию.

