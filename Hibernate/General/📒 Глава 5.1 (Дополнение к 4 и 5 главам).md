
## Hibernate.initialize()

Принудительная инициализация ленивой коллекции/прокси.

```java
Department d = session.get(Department.class, 1L);
Hibernate.initialize(d.getEmployees()); // подгрузит коллекцию
```

Под капотом: если коллекция была `LAZY` и не загружена → Hibernate сделает SQL и загрузит её.

Используют, если нужно закрыть сессию, но при этом сохранить все данные.


***

## Дубликаты при ленивой загрузке

Если сделать `JOIN FETCH` на коллекцию, Hibernate возвращает **дубликаты родительских сущностей**.

```java
List<Department> deps = session.createQuery(
    "select d from Department d join fetch d.employees", Department.class
).list();
```

SQL возвращает строки вида:

```
IT | Petrov
IT | Ivanov
HR | Sidorov
```

➡ Hibernate соберёт `Department`, но т.к. в `List` попадают все строки, мы увидим дубликаты.

✅ Решение: `distinct` в HQL.

```sql
select distinct d from Department d join fetch d.employees
```


***

## Проекция в DTO

Стандарт:

```sql
List<EmployeeDTO> list = session.createQuery(
    "select new com.example.EmployeeDTO(e.id, e.fullName) from Employee e",
    EmployeeDTO.class
).list();
```

⚠️ Минус — нужно указывать полный пакет.


Альтернативы:

### Spring Data Projection

Spring Data JPA позволяет описать DTO **через интерфейсы или классы** без явного конструктора.

```java
public interface EmployeeView {
    Long getId();
    String getFullName();
    String getDepartmentName(); // можно alias
}
```

```java
public interface EmployeeRepository extends JpaRepository<Employee, Long> {

    @Query("select e.id as id, e.fullName as fullName, e.department.name as departmentName " +
           "from Employee e")
    List<EmployeeView> findAllEmployeeViews();
}
```

⚡ Hibernate под капотом сгенерирует анонимную реализацию интерфейса `EmployeeView` и вернёт список.


**Nested Projection**

```java
public interface DepartmentView {
    Long getId();
    String getName();
    List<EmployeeView> getEmployees();

    interface EmployeeView {
        Long getId();
        String getFullName();
    }
}
```

```java
@Query("select d from Department d")
List<DepartmentView> findAllDepartments();
```

⚡ Здесь Spring Data под капотом сам выполнит `JOIN` и подтянет сотрудников.


### @SqlResultSetMapping

* позволяет описать, **как результат SQL-запроса должен быть преобразован** в объект.

✅ Сложные SQL (CTE, оконные функции, агрегаты)

✅ Когда JPQL не справляется

✅ Если нужна **чистая оптимизация** (писать руками запросы под БД)


* можно маппить:
  1. **На сущности** (`entities`)
  2. **На DTO** (`columns` → конструктор)
  3. **Комбинированные результаты** (несколько сущностей + DTO)


#### Пример 1. Mapping на DTO (конструктор)

```java
public record EmployeeDepartmentDto(Long employeeId, String employeeName, String departmentName) {}
```

```java
@SqlResultSetMapping(
    name = "EmployeeDepartmentMapping",
    classes = {
        @ConstructorResult(
            targetClass = com.example.dto.EmployeeDepartmentDto.class,
            columns = {
                @ColumnResult(name = "employee_id", type = Long.class),
                @ColumnResult(name = "employee_name", type = String.class),
                @ColumnResult(name = "department_name", type = String.class)
            }
        )
    }
)
@Entity
@Table(name = "employee")
public class Employee {
    @Id
    private Long id;
    private String fullName;

    @ManyToOne
    private Department department;
}
```

```java
List<EmployeeDepartmentDto> result = em
    .createNativeQuery(
        "select e.id as employee_id, e.full_name as employee_name, d.name as department_name " +
        "from employee e join department d on e.department_id = d.id",
        "EmployeeDepartmentMapping"
    )
    .getResultList();
```


#### Пример 2. Mapping на сущности

```java
@SqlResultSetMapping(
    name = "EmployeeWithDepartmentEntityMapping",
    entities = {
        @EntityResult(entityClass = Employee.class),
        @EntityResult(entityClass = Department.class)
    }
)
```

```java
List<Object[]> result = em.createNativeQuery(
        "select e.*, d.* " +
        "from employee e join department d on e.department_id = d.id",
        "EmployeeWithDepartmentEntityMapping"
    )
    .getResultList();

for (Object[] row : result) {
    Employee emp = (Employee) row[0];
    Department dep = (Department) row[1];
}
```


#### Пример 3. Комбинированный результат (Entity + DTO)

```java
@SqlResultSetMapping(
    name = "EmployeeMixedMapping",
    entities = {
        @EntityResult(entityClass = Employee.class)
    },
    classes = {
        @ConstructorResult(
            targetClass = com.example.dto.DepartmentDto.class,
            columns = {
                @ColumnResult(name = "department_id", type = Long.class),
                @ColumnResult(name = "department_name", type = String.class)
            }
        )
    }
)
```

```java
List<Object[]> result = em.createNativeQuery(
        "select e.*, d.id as department_id, d.name as department_name " +
        "from employee e join department d on e.department_id = d.id",
        "EmployeeMixedMapping"
    ).getResultList();

for (Object[] row : result) {
    Employee emp = (Employee) row[0];
    DepartmentDto depDto = (DepartmentDto) row[1];
}
```


### record

```java
public record DepartmentDto(Long id, String name) {}
public record EmployeeDto(Long id, String fullName) {}
```

```java
List<DepartmentDto> departments = em.createQuery(
    "select new com.example.dto.DepartmentDto(d.id, d.name) from Department d",
    DepartmentDto.class
).getResultList();
```

⚡ Hibernate умеет создавать `record` так же, как обычные DTO-классы с конструктором.


***

## `join d.employees e` — почему так?

JPQL работает с **объектными связями**, а не с таблицами.

```sql
select d.name, count(e) 
from Department d join d.employees e 
group by d.name
```

* `d.employees` — это поле из сущности `Department` (`List<Employee>`).
* JPQL не знает таблиц напрямую, только **атрибуты сущностей**.

❌ Нельзя написать `join Employee e` без связи, потому что Hibernate не понимает, как соединить сущности (какой FK).


***

## Bulk operations

Bulk = массовые операции без загрузки объектов в память.

```java
// update
int updated = session.createQuery(
    "update Employee e set e.salary = e.salary * 1.1 where e.department.name = :depName")
    .setParameter("depName", "IT")
    .executeUpdate();

// delete
int deleted = session.createQuery(
    "delete from Employee e where e.department.name = :depName")
    .setParameter("depName", "HR")
    .executeUpdate();
```

Hibernate здесь **не загружает объекты**, а напрямую выполняет SQL.


***

## `session.clear()` после bulk

Проблема: bulk-запросы **обходят Persistence Context**.

```java
Employee e = session.get(Employee.class, 1L);
System.out.println(e.getSalary()); // 1000

session.createQuery("update Employee set salary = 2000").executeUpdate();

System.out.println(e.getSalary()); // ❌ 1000 (старое значение в кэше!)
```

➡ В памяти (`Persistence Context`) старые данные, они расходятся с БД.

✅ Решение: `session.clear()` или `session.refresh(entity)`.

```java
session.clear(); // очищает контекст, все сущности становятся detached
```

