
**JPQL/HQL** → строковые запросы:

```java
em.createQuery("select e from Employee e where e.salary > 1000", Employee.class)
```

⚠️ Минусы: нет проверки на этапе компиляции, легко ошибиться в строке.

**Criteria API** → объектное построение запросов:

```java
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Employee> cq = cb.createQuery(Employee.class);
Root<Employee> root = cq.from(Employee.class);
cq.select(root).where(cb.gt(root.get("salary"), 1000));

List<Employee> result = em.createQuery(cq).getResultList();
```

✅ Проверяется компилятором (имена полей → строки, но структура запроса → классы).

✅ Удобно строить динамические запросы (фильтры, сортировка, пагинация).


***

## Основные шаги построения запроса

1. Получаем `CriteriaBuilder`

```java
CriteriaBuilder cb = em.getCriteriaBuilder();
```

1. Создаём `CriteriaQuery` для типа результата

```java
CriteriaQuery<Employee> cq = cb.createQuery(Employee.class);
```

1. Определяем "корень" запроса (`Root`)

```java
Root<Employee> root = cq.from(Employee.class);
```

1. Формируем селект и условия

```java
cq.select(root).where(cb.equal(root.get("department").get("name"), "IT"));
```

1. Выполняем запрос

```java
List<Employee> employees = em.createQuery(cq).getResultList();
```


***

## Условия (`Predicate`)

```java
Predicate p1 = cb.gt(root.get("salary"), 1000); // salary > 1000
Predicate p2 = cb.equal(root.get("department").get("name"), "IT"); // department.name = 'IT'

cq.where(cb.and(p1, p2)); // salary > 1000 AND department.name = 'IT'
```


***

## Сортировка

```java
cq.orderBy(cb.asc(root.get("fullName")));  // ORDER BY fullName ASC
```


***

## Агрегации и группировка

```java
CriteriaQuery<Object[]> cq = cb.createQuery(Object[].class);
Root<Employee> root = cq.from(Employee.class);

cq.multiselect(root.get("department").get("name"), cb.count(root))
  .groupBy(root.get("department").get("name"))
  .having(cb.gt(cb.count(root), 5));

List<Object[]> result = em.createQuery(cq).getResultList();
```

SQL-аналог:

```sql
SELECT d.name, COUNT(*)
FROM employee e
JOIN department d ON e.department_id = d.id
GROUP BY d.name
HAVING COUNT(*) > 5;
```


***

## Join-операции

```java
Root<Employee> root = cq.from(Employee.class);
Join<Employee, Department> dep = root.join("department");

cq.select(root).where(cb.equal(dep.get("name"), "IT"));
```

SQL-аналог:

```sql
SELECT e.*
FROM employee e
JOIN department d ON e.department_id = d.id
WHERE d.name = 'IT';
```


***

## Subquery (подзапросы)

```java
Subquery<Double> sub = cq.subquery(Double.class);
Root<Employee> subRoot = sub.from(Employee.class);
sub.select(cb.avg(subRoot.get("salary")));

cq.select(root).where(cb.gt(root.get("salary"), sub));
```

SQL-аналог:

```java
SELECT *
FROM employee e
WHERE e.salary > (SELECT AVG(salary) FROM employee);
```


***

## DTO Projection через Criteria

```java
CriteriaQuery<EmployeeDto> cq = cb.createQuery(EmployeeDto.class);
Root<Employee> root = cq.from(Employee.class);

cq.select(cb.construct(EmployeeDto.class, root.get("id"), root.get("fullName")));

List<EmployeeDto> list = em.createQuery(cq).getResultList();
```

⚡ DTO создаётся через конструктор (`new` в Criteria API).


***

## Динамические фильтры

Главная сила Criteria API — можно динамически собирать список `Predicate` и применять:

```java
List<Predicate> predicates = new ArrayList<>();

if (minSalary != null) {
    predicates.add(cb.gt(root.get("salary"), minSalary));
}
if (departmentName != null) {
    predicates.add(cb.equal(root.get("department").get("name"), departmentName));
}

cq.where(predicates.toArray(new Predicate[0]));
```


***

## Когда использовать Criteria API

✅ Нужно строить **динамические запросы** (поиск с фильтрами, поиск по параметрам из формы).

✅ Когда хочется **type-safety** (структура запроса проверяется компилятором).

✅ Когда проект ориентирован на JPA-спецификацию.

⚠️ Когда **лучше не использовать**:

* Если запросы фиксированные и простые → проще JPQL/HQL.
* Код Criteria API громоздкий и плохо читается.


***

## Современные альтернативы

* **Spring Data JPA `Specifications`** → тонкая обёртка над Criteria API.
* **QueryDSL** → более читаемый DSL.
* **JOOQ** → полноценный SQL DSL, но не JPA.

