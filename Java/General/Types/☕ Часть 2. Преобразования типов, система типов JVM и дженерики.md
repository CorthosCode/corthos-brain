
## 1. Преобразования типов (Type Conversion)

Java выполняет преобразования типов либо **автоматически (widening)**, либо требует **явного (narrowing)**.


### 1.1 Автоматическое расширение (Widening Conversion)

* Когда меньший тип преобразуется в больший **без потери данных**.
* Пример:

```java
int i = 42;
long l = i;     // int → long
double d = l;   // long → double
```

Поддерживаемые преобразования:

* `byte → short → int → long → float → double`
* `char → int → long → float → double`


### 1.2 Явное сужение (Narrowing Conversion)

* Когда больший тип преобразуется в меньший → **возможна потеря данных**.
* Требуется явное приведение `(type)`.
* Пример:

```java
long l = 123456789L;
int i = (int) l;   // потеря данных (обрезается)
```


### 1.3 Приведение ссылочных типов

* Используется для наследования и интерфейсов.
* **Upcasting** (к базовому типу) — безопасен:

```java
Object obj = "Hello"; // String → Object
```

* **Downcasting** (к производному типу) — может вызвать `ClassCastException`:

```java
Object obj = "Hello";
String s = (String) obj; // OK
Integer n = (Integer) obj; // Ошибка во время выполнения
```


### 1.4 Promotion (Расширение в выражениях)

В арифметических операциях:

* Все `byte`, `short`, `char` автоматически поднимаются до `int`.
* Если в выражении участвуют `long`, `float`, `double` → результат приводится к самому «широкому» типу.

Пример:

```java
byte b1 = 1, b2 = 2;
byte b3 = (byte) (b1 + b2); // нужно приведение, т.к. результат int
```


### 1.5 Автобоксинг и распаковка

* Java автоматически преобразует **примитивы ↔ обёртки**.
* Но надо помнить про `NullPointerException` при распаковке:

```java
Integer x = null;
int y = x;  // NPE!
```


***

## 2. Система типов JVM

Java-код компилируется в **байткод JVM**, где есть своя типовая система.


### 2.1 Примитивные типы в JVM

* `int`, `long`, `float`, `double` хранятся напрямую.
* `byte`, `short`, `char`, `boolean` внутри байткода обычно представлены как `int`.
  * Например, `boolean` может храниться как 0/1 (`int`).


### 2.2 Reference types

* Любой объект хранится как **ссылка**.
* JVM не знает различий между `String`, `Object`, `List` → всё это «ссылки».
* Типизация обеспечивается **верификацией байткода** (Bytecode Verifier).


### 2.3 Erasure (Стирание типов)

* JVM **не хранит информацию о дженериках**.
* Например:

```java
List<String> list1 = new ArrayList<>();
List<Integer> list2 = new ArrayList<>();
System.out.println(list1.getClass() == list2.getClass()); // true
```

Это называется **type erasure** — во время компиляции типы параметров стираются до «сырого типа» (`List`).

[☕ Type erasure (стирание типов) — ключевая особенность дженериков (обобщений) в Java.](file:///workspace/6873b63c-7b27-4903-873e-656e6b87e61d/e1URnUygjfgj-qG_kEA9_)


***

## 3. Дженерики (Generics)


### 3.1 Зачем нужны

* Чтобы работать с **параметризованными типами** и избежать `ClassCastException`.
* До Java 5 коллекции были небезопасны:

```java
List list = new ArrayList();
list.add("Hello");
Integer n = (Integer) list.get(0); // ClassCastException
```

С дженериками:

```java
List<String> list = new ArrayList<>();
list.add("Hello");
// list.add(123); // ошибка компиляции
String s = list.get(0); // безопасно
```


### 3.2 Ограниченные типы (Bounded types)

* Ограничение сверху (`extends`):

```java
class Box<T extends Number> { ... }
Box<Integer> b = new Box<>(); // ок
Box<String> b2 = new Box<>(); // ошибка
```

* Ограничение интерфейсами:

```java
class Worker<T extends Runnable & Serializable> { ... }
```


### 3.3 Wildcards (`?`)

* Неизвестный тип:

```java
List<?> list = new ArrayList<String>();
```

* Ограничение сверху:

```java
List<? extends Number> nums = new ArrayList<Integer>();
```

* Ограничение снизу:

```java
List<? super Integer> nums = new ArrayList<Number>();
```


### 3.4 Проблемы с дженериками

* Нет информации о типах во время выполнения (type erasure).
* Нельзя создать `new T()`.
* Нельзя использовать массивы параметризованных типов (`new List<String>[10]` → ошибка).
* Иногда нужны «type tokens»:

```java
public <T> T create(Class<T> clazz) throws Exception {
    return clazz.getDeclaredConstructor().newInstance();
}
```


***

## 4. Массивы и ковариантность vs Дженерики и инвариантность

* Массивы ковариантны:

```java
String[] arr = new String[10];
Object[] objArr = arr; // ковариантность
objArr[0] = 123; // ArrayStoreException во время выполнения
```

* Дженерики инвариантны:

```java
List<String> list = new ArrayList<>();
// List<Object> objs = list; // ошибка компиляции
```

* Но можно использовать wildcard:

```java
List<? extends Object> objs = list; // ок
```


***

## 5. var, generics и type inference

С Java 10:

```java
var list = new ArrayList<String>(); // тип → ArrayList<String>
```

* Компилятор сам выводит тип.
* Но `var` не работает с неинициализированными переменными:

```java
var x; // ошибка
```

