
## 1. Reflection и типы данных в рантайме

Java предоставляет мощный API для работы с типами в рантайме — **Reflection API** (пакет `java.lang.reflect`).


### 1.1 Получение информации о типе

```java
Class<?> clazz = String.class;
System.out.println(clazz.getName());   // java.lang.String
System.out.println(clazz.isPrimitive()); // false
```

Через `.class` или `obj.getClass()` можно получить объект `Class`, который представляет тип.


### 1.2 Примитивы и обёртки

* Примитивы тоже имеют `Class`-объекты:

```java
Class<?> c1 = int.class;
Class<?> c2 = Integer.class;
System.out.println(c1.isPrimitive()); // true
System.out.println(c2.isPrimitive()); // false
```


### 1.3 Доступ к параметрам дженериков

Из-за **type erasure** дженерики стираются, но через `Field` и `Method` можно получить `ParameterizedType`:

```java
import java.lang.reflect.*;

class Box<T> {
    List<String> list;
}

Field f = Box.class.getDeclaredField("list");
Type type = f.getGenericType();
if (type instanceof ParameterizedType) {
    ParameterizedType pt = (ParameterizedType) type;
    System.out.println(pt.getActualTypeArguments()[0]); // class java.lang.String
}
```


***

## 2. Аннотации как типы

В Java аннотации (`@interface`) — это **специальные типы**.


### 2.1 Определение аннотации

```java
@interface MyAnnotation {
    String value();
    int version() default 1;
}
```


### 2.2 Применение

```java
@MyAnnotation(value="Test", version=2)
class Example { }
```


### 2.3 Работа через Reflection

```java
MyAnnotation ann = Example.class.getAnnotation(MyAnnotation.class);
System.out.println(ann.value());   // Test
System.out.println(ann.version()); // 2
```

Аннотации — это полноценные типы, которые компилятор и фреймворки (Spring, Hibernate) активно используют.


***

## 3. Новые типовые конструкции в Java


### 3.1 `record` (Java 14+)

* Иммутабельные data-классы.
* Это **новый вид ссылочного типа**.
* Автоматически генерируются `equals`, `hashCode`, `toString`, конструктор.

Пример:

```java
record Point(int x, int y) { }

Point p = new Point(10, 20);
System.out.println(p.x()); // 10
```


### 3.2 Sealed classes (Java 17+)

* Ограничивают **иерархию наследования**.
* Полезно для **исчерпывающих switch** (pattern matching).

Пример:

```java
sealed interface Shape permits Circle, Rectangle { }

final class Circle implements Shape { }
final class Rectangle implements Shape { }
```

Использование:

```java
static String printShape(Shape s) {
    return switch (s) {
        case Circle c -> "Circle";
        case Rectangle r -> "Rectangle";
    };
}
```


### 3.3 var (Java 10) и record — сочетание

Можно объединять:

```java
var p = new Point(5, 6); // тип автоматически → Point
```


### 3.4 pattern matching for instanceof (Java 16+)

Улучшает работу с типами:

```java
Object obj = "Hello";

if (obj instanceof String s) {
    System.out.println(s.toUpperCase());
}
```


***

## 4. Продвинутые темы системы типов


### 4.1 Intersection types (Пересечение типов)

* Можно ограничить тип несколькими интерфейсами:

```java
  <T extends Runnable & Serializable> void run(T obj) { ... }
```

Это «пересечение типов»: объект должен реализовывать **оба интерфейса**.


### 4.2 Union types

В чистой Java нет union-типов (`A | B`), но Java 19+ добавила **pattern matching for switch**, где можно указывать несколько типов:

```java
static void test(Object obj) {
    switch (obj) {
        case String s -> System.out.println("String: " + s);
        case Integer i -> System.out.println("Integer: " + i);
        default -> System.out.println("Other");
    }
}
```


### 4.3 Type inference (вывод типов)

Компилятор может сам выводить параметры дженериков:

```java
public static <T> List<T> listOf(T... elements) {
    return Arrays.asList(elements);
}

var list = listOf("a", "b", "c"); // List<String>
```


### 4.4 Reifiable vs Non-Reifiable types

* **Reifiable types** (сохраняют информацию в runtime): `String`, `Integer[]`, `List<?>`.
* **Non-Reifiable types** (стираются): `List<String>`, `List<Integer>`.
* Поэтому:

```java
List<String> list1 = new ArrayList<>();
List<Integer> list2 = new ArrayList<>();
System.out.println(list1.getClass() == list2.getClass()); // true
```


***

## 5. Пример: объединение всего

```java
record User(String name, int age) { }

@Deprecated
class Example<T extends Number & Comparable<T>> {
    List<T> list = new ArrayList<>();

    void add(T value) {
        list.add(value);
    }
}

public class Test {
    public static void main(String[] args) throws Exception {
        // var и record
        var u = new User("Alice", 25);
        System.out.println(u);

        // Reflection
        Class<?> c = u.getClass();
        System.out.println(c.isRecord()); // true

        // Дженерики + reflection
        Field f = Example.class.getDeclaredField("list");
        ParameterizedType pt = (ParameterizedType) f.getGenericType();
        System.out.println(pt.getActualTypeArguments()[0]); // T

        // instanceof pattern matching
        Object obj = "Hi";
        if (obj instanceof String s) {
            System.out.println(s.toUpperCase());
        }
    }
}
```

