
## 1. История и предпосылки
  
- **Появилось в Java 8 (2014)** как часть большого обновления языка.  
- Цель: обеспечить **функциональный подход** к работе с коллекциями и последовательностями данных.  
- До Stream API:  
  - Работа с коллекциями была **императивной**: `for, while,` вложенные циклы.  
  - Сложно выражать сложные операции (фильтрация → сортировка → агрегация).  
  - Нет встроенной поддержки параллелизма.  

Пример "до":
```java
List<String> result = new ArrayList<>();
for (String s : strings) {
    if (s.length() > 3) {
        result.add(s.toUpperCase());
    }
}
Collections.sort(result);
```

После Stream API:
```java
List<String> result = strings.stream()
    .filter(s -> s.length() > 3)
    .map(String::toUpperCase)
    .sorted()
    .toList(); // Java 16+
```

> **Stream API — это не структура данных,** а **последовательность элементов,** поддерживаемая источником (коллекция, массив, генератор и т.д.), над которой можно выполнять **декларативные операции.**  


---

## 2. Что такое Stream?

**Stream** — это **абстракция** для обработки последовательности элементов:  
  
- Не хранит данные (в отличие от коллекций).  
- **Ленив** — промежуточные операции не выполняются, пока не вызвана терминальная.  
- **Одноразовый** — после терминальной операции поток закрывается.  
- **Не изменяет источник** — все операции создают новый результат.  
- Может быть **последовательным** или **параллельным** (`parallelStream()`).  


---

## 3. Как устроен Stream внутри?  
  
Stream API основан на **пайплайне (конвейере)** операций:  
  
- **Источник** → **Промежуточные операции (intermediate)** → **Терминальная операция (terminal)**  
### Внутренние компоненты:  
  
1. **Spliterator** (`java.util.Spliterator`) —  
   - Заменяет `Iterator` для потоков.  
   - Поддерживает **разделение** (splitting) для параллельной обработки.  
   - Используется как источник данных для `Stream.`  
  
2. **Pipeline** —  
   - Каждый вызов промежуточной операции (`filter`, `map`) создаёт новый **объект-обёртку** над предыдущим этапом.  
   - Реализован через **цепочку объектов** (`ReferencePipeline`, `StatefulOp, StatelessOp` и др.).  
  
3. **Флаги и оптимизации** —  
   - Stream отслеживает характеристики данных (например, `DISTINCT, SORTED,` `SIZED`). 
   - Использует это для **оптимизации выполнения** (например, пропускает сортировку, если уже отсортировано).  
  
4. **Параллелизм** —  
   - При вызове `parallel(),` Stream использует **ForkJoinPool.**  
   - Данные разделяются через `Spliterator.trySplit().`  
  
> **Важно:** промежуточные операции **не выполняются,** пока не вызвана терминальная. Это называется **ленивой оценкой.**


---

## 4. Типы операций
  
### 4.1. Промежуточные (Intermediate)

Возвращают **новый Stream,** могут быть **конвейеризованы.**  

| Метод                             | Описание                                                        |
| --------------------------------- | --------------------------------------------------------------- |
| `filter(Predicate)`               | Оставляет элементы, удовлетворяющие условию                     |
| `map(Function)`                   | Преобразует каждый элемент                                      |
| `flatMap(Function)`               | Преобразует в поток и "выравнивает"                             |
| `distinct()`                      | Убирает дубликаты                                               |
| `sorted()` / `sorted(Comparator)` | Сортирует                                                       |
| `peek(Consumer)`                  | Для отладки — применяет действие без изменения                  |
| `limit(n), skip(n)`               | Ограничение и пропуск элементов                                 |
| `takeWhile(Predicate)` (Java 9)   | Берёт элементы **до первого,** не удовлетворяющего условию      |
|  `dropWhile(Predicate)` (Java 9)  | Пропускает элементы **до первого,** не удовлетворяющего условию |
  
> Все промежуточные операции — **ленивые.**  


### 4.2. Терминальные (Terminal)

**Запускают выполнение** конвейера и **возвращают результат** (или `void`).  
  
| Метод                                                          | Описание                                             |
| -------------------------------------------------------------- | ---------------------------------------------------- |
|  `forEach(Consumer)`                                           | Выполняет действие для каждого элемента              |
|  `forEachOrdered(Consumer)`                                    | Гарантирует порядок (важно для параллельных потоков) |
|  `collect(Collector)`                                          | Собирает результат в коллекцию/структуру             |
|  `reduce(BinaryOperator)`                                      | Сворачивает поток в одно значение                    |
|  `count()`                                                     | Возвращает количество элементов                      |
|  `min(), max()`                                                | Находит минимум/максимум                             |
|  `anyMatch(), allMatch(), noneMatch()`                         | Проверяют условия                                    |
|  `findFirst(), findAny()`                                      | Возвращают `Optional` первого или любого элемента    |
|  `toList()` (Java 16)                                          | Удобный способ собрать в `List` (неизменяемый)       |
|  `toSet(), toMap()` — только через `collect(Collectors.to...)` |                                                      |
  
> После терминальной операции поток **нельзя переиспользовать.**  
  

---

## 5. Collectors и сбор данных

`Collectors` — утилитный класс для сбора результатов:  

```java
List<String> result = stream.collect(Collectors.toList());
Set<String> unique = stream.collect(Collectors.toSet());
Map<String, Integer> map = stream.collect(Collectors.toMap(String::toString, String::length));
```

**Java 16+:**  добавлены удобные методы:

```java
.stream().toList();        // неизменяемый List
.stream().toSet();         // Java 21+ (ожидается, но уже в preview)
```

> `toList()` возвращает **неизменяемый список** (в отличие от `Collectors.toList()`).  


---

## 6. Особенности Java 21 и 25 (на ноябрь 2025)
  
- **Stream API остается стабильным:** последние 10 лет API почти не менялся.  
- **Java 16 (2021):** добавлен `Stream.toList().`  
- **Java 19–21:** улучшена производительность внутренних операций, оптимизация `Spliterator.`  
- **Java 21 (2023):** LTS-релиз. Stream API без изменений в публичном API.  
- **Java 22–25 (до ноября 2025):**  
  - В preview-фичах **не было** изменений Stream API.  
  - Возможно, в Java 25 появится `Stream.toUnmodifiableList()` или аналоги, но это маловероятно — API считается «завершённым».  
  
> **Вывод:** Stream API — зрелая, стабильная часть Java. Изменения минимальны после Java 8.  


---

## 7. Пример: полный пайплайн

```java
List<String> names = List.of("Alice", "Bob", "Charlie", "David");

List<String> result = names.stream()
    .filter(name -> name.length() > 4)
    .map(String::toUpperCase)
    .sorted()
    .limit(2)
    .toList(); // Java 16+

// Результат: ["ALICE", "CHARLIE"]
```


---  
  
## 8. Распространённые ошибки
  
- **Использование `forEach` вместо `collect`** — теряет преимущества ленивости и композиции.  
- **Изменение состояния из лямбд** (`side effects`) — нарушает функциональный стиль.  
- **Непонимание ленивости** — например, ожидание выполнения `filter` без терминальной операции.  
- **Использование `parallelStream()` без профилирования** — может ухудшить производительность при малых данных. 

