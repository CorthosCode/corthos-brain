
**Scoped Values** — это механизм передачи неизменяемых данных в пределах определенной области видимости (scope) в Java-приложении. Предназначен для замены ThreadLocal в сценариях, где данные не должны изменяться в пределах логической единицы работы, особенно при использовании **виртуальных потоков**. Scoped Values обеспечивают безопасную передачу данных между фреймворками и прикладным кодом, улучшая производительность и уменьшая потребление памяти по сравнению с ThreadLocal в определенных сценариях.


[[☕ 14. Виртуальные потоки (Virtual Threads)]]


---

## Основные компоненты

1. **`ScopedValue<T>`**:
    - Статический класс, представляющий "ключ" и "контейнер" для значения определенного типа `T`.
    - Используется для _хранения_ и _получения_ значения в пределах текущей области видимости.
    - Создается с помощью `ScopedValue.newInstance()`.

2. **`ScopedValue.where(ScopedValue<T> key, T value)`**:
    - Создает _область видимости_ (scope), в которой `key` ассоциируется с `value`.
    - Возвращает объект, на котором можно вызвать метод `run(Runnable)` или `call(Callable<V>)`.

3. **`run(Runnable)` / `call(Callable<V>)`**:
    - Методы, которые _выполняют_ переданный код _внутри_ созданной области.
    - Код, выполняющийся внутри `run`/`call`, может получить доступ к значению через `ScopedValue.get()`.

4. **`ScopedValue.get(ScopedValue<T> key)`**:
    - Получает текущее значение `key` в _текущей_ области видимости.
    - Вызывает `NullPointerException`, если `key` равен `null`.
    - Вызывает `WrongThreadException`, если вызывается вне области действия `key` (в том числе в другом потоке, если область не была передана).
    - Вызывает `UnboundException`, если `key` не привязан к текущей области (например, если `where()` не было вызвано или область вышла из-под нее).


---

## Ключевые особенности и принципы работы

- **Неизменяемость (Immutability)**: Значения, связанные с `ScopedValue`, неизменяемы в пределах своей области. После создания области значение не может быть изменено.
- **Область видимости (Scoping)**: Значение доступно только в коде, который _выполняется_ внутри `run`/`call` соответствующего `ScopedValue.where(...)`. Это строгое лексическое ограничение.
- **Передача между потоками**: Область действия _не передается_ автоматически между потоками. Вызов `ScopedValue.get()` в другом потоке (например, в `Thread.startVirtualThread()`) приведет к `WrongThreadException`. Для передачи между виртуальными потоками, созданными через `Thread.ofVirtual().inheritAll()`, область _наследуется_.
- **Отсутствие поддержки на уровне JVM**: В отличие от ThreadLocal, Scoped Values не полагаются на низкоуровневую поддержку JVM. Это делает их потенциально более эффективными с точки зрения памяти, особенно с виртуальными потоками, где хранение данных в каждом потоке может быть накладно.
- **Назначение**: Основное назначение — передача _контекстных_ данных (например, ID запроса, информации о пользователе, настроек безопасности) внутри логической единицы работы (например, обработки HTTP-запроса), где изменение этих данных нежелательно или не ожидается.


---

## Примеры использования

```java
import java.util.concurrent.ThreadLocalRandom;

public class ScopedValueExample {

    // 1. Создаем ScopedValue для хранения ID запроса
    private static final ScopedValue<String> REQUEST_ID = ScopedValue.newInstance();

    public static void main(String[] args) {
        // 2. Создаем уникальный ID запроса
        String id = "req-" + ThreadLocalRandom.current().nextInt(1000);

        // 3. Устанавливаем значение в области и выполняем код
        ScopedValue.where(REQUEST_ID, id)
                   .run(() -> {
                       System.out.println("Request ID in main scope: " + REQUEST_ID.get());

                       // Вызов вложенного метода
                       nestedMethod();

                       // Вызов метода, запускающего виртуальный поток (с наследованием)
                       callVirtualThreadWithInheritance();
                   });

        // REQUEST_ID.get() здесь вызовет UnboundException
    }

    private static void nestedMethod() {
        System.out.println("Request ID in nested method: " + REQUEST_ID.get());
    }

    private static void callVirtualThreadWithInheritance() {
        // Создаем виртуальный поток с наследованием
        Thread virtualThread = Thread.ofVirtual()
                                     .inheritAll() // <-- ВАЖНО: включаем наследование
                                     .factory()
                                     .newThread(() -> {
                                         // Область наследуется, доступно
                                         System.out.println("Request ID in inherited virtual thread: " + REQUEST_ID.get());
                                     });

        try {
            virtualThread.start();
            virtualThread.join(); // Ждем завершения
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```


---

## Сравнение с ThreadLocal

| **Характеристика**     | **ThreadLocal**                               | **ScopedValue**                          |
| ---------------------- | --------------------------------------------- | ---------------------------------------- |
| **Изменяемость**       | Да (значение можно менять)                    | Нет (значение фиксировано в scope)       |
| **Область действия**   | Поток                                         | Лексическая область выполнения           |
| **Передача в потоки**  | Нет (обычно)                                  | Да (с`inheritAll()`)                     |
| **Производительность** | Потенциально накладно с виртуальными потоками | Эффективнее с виртуальными потоками      |
| **Назначение**         | Локальные данные потока, часто изменяемые     | Контекстные данные, неизменяемые в scope |


---

## Когда использовать Scoped Values

- Когда нужно передать неизменяемый контекст (например, ID трассировки, информацию о пользователе, настройки безопасности) через несколько уровней вызовов методов без явной передачи параметров.
- В приложениях, активно использующих виртуальные потоки, где `ThreadLocal` может привести к увеличению потребления памяти.
- Когда важна предсказуемость и отсутствие возможности случайного изменения значения в пределах логической единицы работы.


---

## Ограничения и важные моменты

- `ScopedValue.get()` _должен_ вызываться из кода, выполняющегося внутри `run`/`call` соответствующего `ScopedValue.where(...)`, иначе будет выброшено исключение.
- Область _не наследуется_ обычными способами передачи выполнения в другой поток (например, `Thread.startVirtualThread(runnable)` без `inheritAll()` или `CompletableFuture`).
- Является _замороженным_ (frozen) интерфейсом, что означает его стабильность.


---

## Официальные источнники

[JEP 446: Scoped Values](https://openjdk.org/jeps/446)

