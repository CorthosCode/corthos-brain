
**Structured Concurrency** — это подход к написанию многопоточного кода, при котором логически связанные задачи и их потоки (включая виртуальные потоки) объединяются в _структурную единицу_, подобно тому, как локальные переменные и вызовы методов образуют структуру в однопоточном коде.

Этот подход делает многопоточный код более надежным, предсказуемым, упрощает отладку и обработку ошибок, а также улучшает управление ресурсами (например, предотвращает утечки потоков). Он введен в Java 19 как.preview, а в Java 21 стал стандартной функциональностью.


---

## Основные компоненты

1. **`StructuredTaskScope<T>`**:
    - Класс, реализующий интерфейс `AutoCloseable`.
    - Представляет собой _область_ (scope) для выполнения подзадач (child tasks).
    - Служит контейнером для вложенных задач, обеспечивая их структурированное выполнение.
    - При завершении области (через `try-with-resources` или явный вызов `close()`) автоматически отменяются все активные подзадачи, и освобождаются связанные ресурсы.

2. **`fork(Callable<T> task)`**:
    - Метод `StructuredTaskScope`.
    - Используется для _запуска_ подзадачи (обычно в виртуальном потоке).
    - Возвращает `StructuredTaskScope.Subtask<T>`, который можно использовать для получения результата или проверки состояния задачи.

3. **`join()` / `joinUntil(Instant deadline)`**:    
    - Методы `StructuredTaskScope`.
    - Основной поток (main thread), вызывающий `join()`, _ожидает завершения всех подзадач_, запущенных через `fork()`.
    - `joinUntil` позволяет указать максимальное время ожидания.
    - Если задача завершается с исключением, это исключение может быть обработано в основном потоке.

4. **`Subtask<T>` (результат `fork()`)**:
    - Представляет запущенную подзадачу.
    - Позволяет получить результат (`get()`), проверить статус (`state()`), получить исключение (`exception()`), и т.д.
    - Метод `get()` может выбросить исключение, если задача завершилась аварийно.


---

## Ключевые принципы и особенности

1. **Иерархия и Вложенность**:
    - Подзадачи, запущенные через `fork()`, принадлежат конкретному `StructuredTaskScope`.
    - Если `StructuredTaskScope` создается _внутри_ другого потока (например, виртуального, запущенного через `Thread.startVirtualThread`), то этот внешний поток становится _родительским_ для `StructuredTaskScope`.
    - Отмена родительского потока (или выход из родительской области) приводит к отмене всех дочерних задач в `StructuredTaskScope`.

2. **Автоматическая отмена и управление ресурсами**:    
    - При выходе из блока `try-with-resources` (или вызове `scope.close()`), все активные подзадачи, запущенные через `fork()`, _принудительно отменяются_.
    - Это предотвращает утечки потоков и упрощает управление ресурсами.

3. **Обработка исключений**:    
    - Исключения, возникшие в подзадачах, могут быть обработаны в основном потоке после `join()`.
    - Это позволяет централизованно обрабатывать ошибки, происходящие в параллельных ветвях.

4. **Определенное время жизни**:    
    - В отличие от `ExecutorService` или `CompletableFuture`, `StructuredTaskScope` предназначен для _кратковременного_ использования в рамках одной логической операции.
    - Его жизненный цикл четко ограничен (например, блоком `try-with-resources`).

5. **Интеграция с виртуальными потоками**:    
    - Structured Concurrency особенно полезен с виртуальными потоками, так как позволяет эффективно управлять большим количеством короткоживущих задач без риска утечки или усложнения логики отмены.


---

## Основные шаблоны использования

### 0. Простой пример

```java
import java.util.concurrent.StructuredTaskScope;

public class StructuredConcurrencyExample {
    public static void main(String[] args) throws InterruptedException {
        try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {
            var future1 = scope.fork(() -> {
                Thread.sleep(1000);
                return "Result 1";
            });
            var future2 = scope.fork(() -> {
                Thread.sleep(500);
                return "Result 2";
            });

            scope.join();  // Ожидаем завершения всех подзадач или аварийного выхода при ошибке
            String result1 = future1.resultNow();
            String result2 = future2.resultNow();
            System.out.println("Results: " + result1 + ", " + result2);
        }
    }
}
```


### 1. Structured Task Scope (Общий случай)

```java
import java.util.concurrent.Callable;
import java.util.concurrent.StructuredTaskScope;
import java.time.Instant;

public class StructuredTaskScopeExample {

    public static void main(String[] args) throws Exception {
        String result = performConcurrentTasks();
        System.out.println("Final Result: " + result);
    }

    static String performConcurrentTasks() throws Exception {
        // Создаем область для выполнения подзадач
        try (var scope = new StructuredTaskScope.ShutdownOnFailure()) { // Или ShutdownOnSuccess()

            // Запускаем подзадачи
            StructuredTaskScope.Subtask<String> userTask = scope.fork(getUser());
            StructuredTaskScope.Subtask<String> orderTask = scope.fork(getOrder());

            // Ждем завершения всех подзадач
            scope.join(); // Или scope.joinUntil(Instant.now().plusSeconds(30));

            // Проверяем, завершились ли все успешно (для ShutdownOnFailure)
            if (scope.state() != StructuredTaskScope.State.SUCCESS) {
                 // Обработка ошибки, если одна из задач завершилась с исключением
                 Subtask<?> failedTask = scope.result(); // Получает первую неудачную задачу
                 throw new RuntimeException("Task failed: " + failedTask.exception());
            }

            // Получаем результаты
            String user = userTask.get(); // Может выбросить исключение задачи
            String order = orderTask.get();
            return user + " - " + order;
        } // scope.close() автоматически вызывается, отменяя подзадачи
    }

    static Callable<String> getUser() {
        return () -> {
            Thread.sleep(2000); // Имитация работы
            return "User123";
        };
    }

    static Callable<String> getOrder() {
        return () -> {
            Thread.sleep(1500); // Имитация работы
            return "Order456";
        };
    }
}
```


### 2. ShutdownOnSuccess (Шаблон "Первый выполнившийся")

```java
import java.util.concurrent.Callable;
import java.util.concurrent.StructuredTaskScope;

public class ShutdownOnSuccessExample {

    public static void main(String[] args) throws Exception {
        String result = fetchFromAnySource();
        System.out.println("Result from first available: " + result);
    }

    static String fetchFromAnySource() throws Exception {
        // Завершает выполнение, как только *одна* задача завершается успешно
        try (var scope = new StructuredTaskScope.ShutdownOnSuccess<String>()) {
            scope.fork(fetchFromServiceA());
            scope.fork(fetchFromServiceB());
            scope.fork(fetchFromServiceC());

            scope.join(); // Ждем, пока хотя бы одна завершится успешно

            // Если ни одна не завершилась успешно, будет исключение
            return scope.result(); // Возвращает результат первой успешной задачи
        }
    }

    static Callable<String> fetchFromServiceA() {
        return () -> {
            Thread.sleep(5000); // Медленный сервис
            return "Data from A";
        };
    }

    static Callable<String> fetchFromServiceB() {
        return () -> {
            Thread.sleep(1000); // Быстрый сервис
            return "Data from B";
        };
    }

    static Callable<String> fetchFromServiceC() {
        return () -> {
             Thread.sleep(3000);
             return "Data from C";
        };
    }
}
```


### 3. ShutdownOnFailure (Шаблон "Все или ничего")

```java
import java.util.concurrent.Callable;
import java.util.concurrent.StructuredTaskScope;

public class ShutdownOnFailureExample {

    public static void main(String[] args) {
        try {
            String result = fetchAllRequiredData();
            System.out.println("All data fetched: " + result);
        } catch (Exception e) {
            System.out.println("Failed to fetch all data: " + e.getMessage());
        }
    }

    static String fetchAllRequiredData() throws Exception {
        // Отменяет все задачи, если *одна* из них завершается с ошибкой
        try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {
            var task1 = scope.fork(fetchCriticalData1());
            var task2 = scope.fork(fetchCriticalData2());

            scope.join(); // Ждем завершения всех

            // Если дойдем до этой точки, все задачи завершились успешно
            return task1.get() + " - " + task2.get();
        }
    }

    static Callable<String> fetchCriticalData1() {
        return () -> "Critical Data 1";
    }

    static Callable<String> fetchCriticalData2() {
        return () -> {
            // Simulate a failure
            throw new RuntimeException("Simulated failure in task 2");
            // return "Critical Data 2";
        };
    }
}
```


---

## Сравнение с CompletableFuture

| **Характеристика**                     | **Structured Concurrency**                                      | **CompletableFuture**                         |
| -------------------------------------- | --------------------------------------------------------------- | --------------------------------------------- |
| **Модель**                             | Структурированная, иерархическая                                | Функциональная, цепочка обработки             |
| **Управление ресурсами**               | Автоматическое (через`try-with-resources`)                      | Ручное (или через`ExecutorService`)           |
| **Отмена задач**                       | Автоматическая при выходе из области                            | Явная (`cancel()`) или при ошибке в цепочке   |
| **Обработка ошибок**                   | Централизованная после`join()`                                  | Встроена в цепочку (`exceptionally`,`handle`) |
| **Назначение**                         | Параллельное выполнение_связанных_задач в рамках одной операции | Сложные асинхронные цепочки и комбинирование  |
| **Сложность отладки**                  | Проще (четкая иерархия)                                         | Сложнее (асинхронные цепочки)                 |
| **Интеграция с виртуальными потоками** | Оптимальна                                                      | Возможна, но требует внимания к ресурсам      |


---

## Когда использовать Structured Concurrency

- Когда нужно выполнить **несколько логически связанных подзадач параллельно** в рамках одной логической операции (например, сбор данных из нескольких источников).
- Когда важна **предсказуемость** и **безопасность отмены** и утечек ресурсов.
- В приложениях, использующих **виртуальные потоки** для кратковременных операций.
- Когда нужен шаблон "первый выполнившийся" (`ShutdownOnSuccess`) или "все или ничего" (`ShutdownOnFailure`).
- Когда хочется упростить **отладку** многопоточного кода за счет структурированности.


---

## Ограничения и важные моменты

- `StructuredTaskScope` предназначен для **однократного** использования в рамках одного блока.
- Подходит для **короткоживущих** задач. Не предназначен для выполнения долгоживущих фоновых задач.
- Является стандартной функциональностью с **Java 21**. В Java 19/20 был.preview.
- Тесно интегрирован с **виртуальными потоками** и работает наиболее эффективно с ними.


---

## Официальные источнники

[Structured Concurrency](https://openjdk.org/jeps/453)

