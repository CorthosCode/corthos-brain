# ☕ Закон Амдала

Brush Stroke

Brush Stroke

Brush Stroke

Brush Stroke

Brush Stroke

Brush Stroke

Brush Stroke

Brush Stroke

Brush Stroke

Brush Stroke

Brush Stroke

Brush Stroke

Brush Stroke

Brush Stroke

Brush Stroke

Brush Stroke

Brush Stroke

Brush Stroke

Brush Stroke

Brush Stroke

Brush Stroke

Brush Stroke

Brush Stroke

Brush Stroke

Brush Stroke

Brush Stroke

Brush Stroke

Brush Stroke

###### Что такое Закон Амдала?

* Математическая формула, описывающая **теоретическое ограничение на ускорение** при параллельной обработке.
* Показывает, **насколько можно ускорить программу**, увеличив количество потоков/процессоров.
* Назван в честь компьютерного архитектора **Джина Амдала**.



###### Основная формула

```java
S = 1 / ((1 - P) + P/N)
```

Где:

* **S** = ускорение (speedup)
* **P** = доля программы, которая может быть параллелизована (0.0 - 1.0)
* **N** = количество процессоров/потоков
* **(1 - P)** = доля программы, которая должна выполняться последовательно



###### Простой пример

Представим программу, которая:

* 80% времени тратит на вычисления (может быть параллелизовано)
* 20% времени тратит на ввод/вывод (должно выполняться последовательно)

```java
P = 0.8 (80% параллельно)
N = 4 процессора
```

Вычисляем ускорение:

```java
S = 1 / ((1 - 0.8) + 0.8/4)
S = 1 / (0.2 + 0.2)
S = 1 / 0.4
S = 2.5
```

**Вывод:** Даже с 4 процессорами мы получим только 2.5-кратное ускорение!



###### Визуализация закона Амдала

```java
Ускорение vs Количество процессоров:

S
↑
8 |           ●
7 |         ●
6 |       ●
5 |     ●
4 |   ●
3 | ●
2 |●
1 |●________________________→ N
  1  2  4  8  16 32 64
```

**Заметьте:** Кривая выходит на плато — добавление процессоров дает всё меньший эффект!



###### Практические примеры из жизни



**1. Веб-сервер**

```java
Задача: Обработка 1000 HTTP запросов
- 90% времени: обработка данных (параллельно) ✅
- 10% времени: проверка лицензии (последовательно) ❌

P = 0.9, N = 10
S = 1 / (0.1 + 0.9/10) = 1 / 0.19 ≈ 5.26

Вывод: Даже с 10 серверами ускорение только ~5x
```

**2. Видео кодирование**

```java
Задача: Кодирование фильма
- 95% времени: кодирование кадров (параллельно) ✅
- 5% времени: заголовки, метаданные (последовательно) ❌

P = 0.95, N = 32
S = 1 / (0.05 + 0.95/32) ≈ 1 / 0.0797 ≈ 12.5

Вывод: Теоретически ~12x ускорение вместо 32x
```



###### Таблица ускорений при разных значениях P

| **P (параллельная часть)** | **N=2** | **N=4** | **N=8** | **N=16** | **N=∞** |
| -------------------------- | ------- | ------- | ------- | -------- | ------- |
| 0.5 (50%)                  | 1.33    | 1.60    | 1.78    | 1.88     | 2.0     |
| 0.8 (80%)                  | 1.67    | 2.50    | 3.33    | 3.64     | 5.0     |
| 0.9 (90%)                  | 1.82    | 3.08    | 4.74    | 5.52     | 10.0    |
| 0.95 (95%)                 | 1.90    | 3.48    | 5.93    | 7.27     | 20.0    |

**Обратите внимание:** Даже при 95% параллелизации ускорение никогда не превысит 20x!



###### Формула по книге



Где:

* **S** = ускорение (speedup)
* **F** = доля вычислений, которые должны выполняться последовательно
* **N** = количество процессоров/потоков
* **(1 - F)** = доля программы, которая должна выполняться последовательно?





***

# Расширение: Закон Густавсона



**Противоположный подход:**

* Вместо фиксированного объема работы — увеличиваем задачу с количеством процессоров
* `S = P × N + (1 - P)`

**Пример:**

```java
P = 0.9, N = 16
S = 0.9 × 16 + 0.1 = 14.5

Вывод: Вместо 5.5x ускорения — 14.5x при увеличении объема задач!
```



###### Как применять на практике

**1. Профилирование**

```java
// Измеряем время выполнения разных частей
long startTime = System.nanoTime();
// Последовательная часть
sequentialProcessing();
long seqTime = System.nanoTime() - startTime;

startTime = System.nanoTime();
// Параллельная часть
parallelProcessing();
long parTime = System.nanoTime() - startTime;

// Вычисляем P
double totalTime = seqTime + parTime;
double P = (double) parTime / totalTime;
```

**2. Планирование ресурсов**

```java
// Оценка оптимального количества потоков
double P = 0.8; // Из профилирования
int optimalThreads = (int) Math.ceil(1 / (1 - P)); // Приблизительно
```

**3. Архитектурные решения**

* Если P < 0.5 — **лучше оптимизировать последовательный код**
* Если P > 0.9 — **инвестируйте в масштабирование**









