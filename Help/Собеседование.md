# Собеседование

Основные концепты включают:

1. **[Инкапсуляция](https://blog.skillfactory.ru/glossary/inkapsulyacziya/)****—**&#x441;крытие внутреннего состояния объекта и предоставление доступа к нему только через методы.
2. **Наследование —**&#x43C;еханизм, позволяющий создавать новый класс на основе существующего.
3. **[Полиморфизм](https://blog.skillfactory.ru/glossary/polimorfizm/)****—**&#x441;пособность одного интерфейса использоваться для представления различных типов.
4. **Абстракция —**&#x432;ыделение общих характеристик объектов и скрытие деталей их реализации.







### **Какие спецификаторы доступа для классов Java?**

В языке Java существуют следующие спецификаторы доступа:

1. **public:**&#x414;оступен из любого другого класса.
2. **protected:**&#x414;оступен из любого класса в том же пакете и подклассов.
3. **default (package-private):**&#x414;оступен только внутри того же пакета.
4. **private:**&#x414;оступен только внутри самого класса.









### **Как работает сбор мусора в Java?**

Сбор мусора (Garbage Collection) в Java автоматически управляет памятью и удаляет объекты, которые больше не используются приложением. Основные алгоритмы GC включают:

**Поиск мёртвых объектов**— GC сканирует кучу на наличие объектов, к которым нет ссылок.

**Удаление мёртвых объектов**— после обнаружения они удаляются, освобождая память.

**Уплотнение памяти**— после удаления объектов память может быть фрагментирована, GC может сдвигать оставшиеся объекты, чтобы освободить более крупные участки памяти.

GC помогает избежать утечек памяти и оптимизировать использование ресурсов.







### **Что такое JVM, JDK, JRE?**

JVM, JDK и JRE - это три основных понятия в мире Java-разработки.

`JVM (Java Virtual Machine)`- виртуальная машина Java , которая выполняет Java-байткод. Все программы на Java компилируются в байткод, который может быть выполнен на любой платформе, на которую установлена JVM.

`JDK (Java Development Kit)`- это пакет разработчика Java , который включает в себя всё необходимое для разработки Java-приложений, включая компилятор javac, библиотеки классов, документацию, примеры кода и JVM.

`JRE (Java Runtime Environment)`- это пакет для запуска Java-приложений, который включает в себя JVM, библиотеки классов и другие необходимые компоненты для запуска Java-приложений.

Кратко говоря, если вы планируете разработку Java-приложений, то вам нужна JDK. Если же вы планируете только запускать Java-приложения, то вам достаточно установить JRE, которая включает в себя JVM.





### **Зачем используют JVM?**

`JVM (виртуальная машина Java)`— важнейший компонент языка программирования Java. Это абстрактная машина, предоставляющая среду выполнения, в которой может выполняться скомпилированный код Java. Вот несколько причин, почему JVM важна и широко используется в разработке программного обеспечения:

* `Переносимость`: код Java можно написать один раз и запустить на любой платформе, на которой установлена ​​JVM, независимо от базового оборудования и операционной системы. Это делает Java-программы легко переносимыми и уменьшает количество кода, необходимого для конкретной платформы.
* `Управление памятью`: JVM управляет распределением памяти и автоматически освобождает неиспользуемую память посредством сборки мусора. Это освобождает разработчиков от утомительной и чреватой ошибками задачи ручного управления памятью.
* `Безопасность`. Поскольку JVM выполняет код Java в изолированной среде, это предотвращает причинение вреда базовой системе вредоносным кодом. Это делает Java популярным выбором для создания безопасных и надежных приложений.
* `Производительность`: JVM создана для оптимизации выполнения кода Java и использует передовые методы, такие как своевременная компиляция, для достижения высокой производительности.





### **Что такое bytecode?**

`Bytecode`в Java - это набор инструкций, разработанных для исполнения на виртуальной машине Java (JVM). Он представляет собой низкоуровневый, но переносимый по архитектуре набор инструкций, который может быть выполняем на любой машине Java. Java-программы компилируются в байт-код, который может быть распространен и загружен на любой машине, на которой установлено соответствующее окружение выполнения Java. После того как байт-код загружается в виртуальную машину, он транслируется в машинный код и исполняется. Это позволяет программам Java быть переносимыми между различными платформами без необходимости перекомпилировать их на каждой платформе.







### **Что такое OutOfMemoryError?**

`OutOfMemoryError`— это ошибка времени выполнения в языке программирования Java, которая возникает, когда виртуальная машина Java (JVM) не может выделить память для создания новых объектов, поскольку пространство кучи заполнено и больше нет места для хранения новых объектов.
`Куча space`— это пространство памяти, используемое JVM для выделения и освобождения объектов, созданных во время выполнения. Важно эффективно управлять использованием памяти в Java, чтобы избежать исключений OutOfMemoryError. Этого можно добиться путем оптимизации кода, сокращения потребления памяти и использования соответствующих методов управления памятью, таких как сборка мусора, эффективные структуры данных и шаблоны проектирования. Кроме того, вы можете увеличить максимальный размер кучи, доступный для JVM, используя такие параметры командной строки, как -Xmx, чтобы избежать нехватки памяти.





### **Назовите все методы класса object.**

В Java все классы наследуются от класса Object. Некоторые методы, определенные в классе Object, включают в себя:

* `getClass()`: возвращает объект Class, который представляет класс объекта
* `hashCode()`: возвращает хэш-код объекта
* `equals(Object obj)`: определяет, равен ли данный объект указанному объекту
* `clone()`: создает и возвращает копию данного объекта
* `toString()`: возвращает строковое представление объекта
* `notify()`: возобновляет выполнение потока, заблокированного на объекте
* `notifyAll()`: возобновляет выполнение всех потоков, заблокированных на данном объекте
* `wait()`: ожидает до тех пор, пока другой поток не уведомит о возможности продолжения выполнения
* `finalize()`: вызывается сборщиком мусора перед тем, как объект будет удален



### **Объекты каких стандартных классов immutable в Java?**

В языке Java объекты классов String, Integer, Byte, Character, Short, Boolean, Long, Double и Float являются immutable. Это означает, что значения их полей не могут быть изменены после создания объекта. Таким образом, любые операции с ними, которые изменяют значение, на самом деле создают новый объект. Примером может быть метод substring() в классе String, который создает новый объект строки, содержащий подстроку из исходной строки. Кроме того, вы также можете создавать свои собственные immutable классы в Java, объявляя поля и устанавливая им значения только в конструкторе, а затем делая их final. Это гарантирует, что их значения не могут быть изменены после создания объекта.





### **Что такое SOLID? Приведите примеры.**

SOLID - это аббревиатура, используемая для описания пяти основных принципов объектно-ориентированного программирования (ООП), которые помогают разработчикам создавать более поддерживаемый и расширяемый код.

* `Принцип единственной ответственности (Single Responsibility Principle, SRP)`- класс должен иметь только одну ответственность. Например, класс, отвечающий за работу с базой данных, не должен также заниматься обработкой пользовательского ввода или выводом на экран.
* `Принцип открытости/закрытости (Open/Closed Principle, OCP)`- классы должны быть открыты для расширения, но закрыты для модификации. Это означает, что новый функционал должен добавляться через добавление новых классов или методов, а не изменение существующих.
* `Принцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP)`- объекты одного класса могут быть заменены объектами другого класса, производного от него, не нарушая работоспособность программы. Например, класс "фрукт" может быть заменен производными классами "яблоко", "груша", "апельсин" и т. д.
* `Принцип разделения интерфейса (Interface Segregation Principle, ISP)`- клиенты не должны зависеть от интерфейсов, которые они не используют. Интерфейсы должны быть маленькими и специфическими для конкретных задач.
* `Принцип инверсии зависимостей (Dependency Inversion Principle, DIP)`- модули верхнего уровня не должны зависеть от модулей нижнего уровня. Их зависимости должны быть инвертированы через абстракции. Например, класс, который использует базу данных, должен зависеть от абстрактного интерфейса базы данных, а не от конкретной реализации базы данных.







### **Что такое Hibernate? В чем разница между JPA и Hibernate?**

`Hibernate`- это фреймворк для работы с реляционными базами данных в Java. Он предоставляет объектно-ориентированный подход к работе с базами данных, что позволяет разработчикам избежать написания большого количества SQL-запросов и упрощает взаимодействие между приложениями и базой данных.

`JPA (Java Persistence API)`- это стандарт для работы с объектно-реляционным отображением (ORM) в Java. Он определяет API для работы с базами данных через ORM. JPA не является конкретной реализацией ORM, а скорее стандартизирует работу с ним.

Hibernate - одна из самых популярных реализаций JPA. Hibernate реализует спецификацию JPA и добавляет дополнительные функциональные возможности и расширения. В частности, Hibernate имеет свой язык запросов HQL (Hibernate Query Language), который позволяет разработчикам писать запросы на высоком уровне абстракции, а также его собственный кэш второго уровня, который улучшает производительность приложения.

Разница между JPA и Hibernate заключается в том, что JPA является стандартом, который имеет несколько реализаций, включая Hibernate, EclipseLink и OpenJPA. Hibernate - одна из самых популярных реализаций JPA и предоставляет наиболее широкий набор функциональных возможностей и расширений. Однако, использование JPA позволяет создавать более переносимый код между различными ORM-фреймворками, а также повышает уровень абстракции взаимодействия с базой данных.







### **Что такое каскадность? Как она используется в Hibernate?**

`Каскадность (Cascade)`- это механизм в Hibernate, позволяющий автоматически распространять операции сохранения, обновления или удаления сущности на связанные с ней объекты.

Каскадность используется в Hibernate для управления связями между сущностями и уменьшения количества кода, необходимого для выполнения операций CRUD (Create, Read, Update, Delete) с базой данных. Без каскадности при изменении состояния одной сущности, например ее удалении, разработчику пришлось бы явно удалять все связанные сущности вручную.



Hibernate поддерживает несколько типов каскадности:

* `CascadeType.ALL`- операция каскадного удаления, сохранения и обновления применяется ко всем связанным сущностям.
* `CascadeType.PERSIST`- каскадное сохранение применяется ко всем связанным сущностям.
* `CascadeType.MERGE`- каскадное обновление применяется ко всем связанным сущностям.
* `CascadeType.REMOVE`- каскадное удаление применяется ко всем связанным сущностям.
* `CascadeType.DETACH`- каскадное отсоединение применяется ко всем связанным сущностям.
* `CascadeType.REFRESH`- каскадное обновление применяется ко всем связанным сущностям.
* `CascadeType.NONE`- каскадность не применяется ни к одной связанной сущности.







### **Дайте характеристику String в Java.**

`String`в Java - это класс, который представляет последовательность символов. Он является неизменяемым (immutable) объектом, что означает, что его значение не может быть изменено после создания.

Характеристики String в Java:

* `Неизменяемость`- значения объекта String нельзя изменить после его создания. Это делает его безопасным для использования в многопоточном окружении и обеспечивает более простое управление памятью.
* `Unicode-кодировка`- в Java строки хранятся в формате Unicode, что позволяет использовать различные символы из разных языковых наборов.
* `Методы работы со строками`- класс String имеет много методов для работы со строками, таких как сравнение, поиск, замена, разделение, конкатенация строк и другие.
* `Пул строк`- Java использует пул строк (string pool), что позволяет экономить память и повышает производительность при работе со строками.
* `Использование в качестве ключей Map`- String часто используется в качестве ключей для Map, благодаря своей неизменяемости и возможности реализации методов hashCode() и equals().
* `Создание объекта String`- объект String можно создать, используя литералы, конструкторы и методы.





### **Что такое пул строк и для чего он нужен?**

В Java пул строк (String Pool) - это механизм, который используется для управления объектами типа String. Этот пул представляет собой специальный область в памяти, где хранятся все уникальные строки, созданные в приложении. При создании новой строки Java автоматически проверяет наличие уже созданной строки с таким же содержимым в пуле строк, и если она там уже есть, то возвращается ссылка на существующий объект String, а не создается новый.

Использование пула строк имеет следующие преимущества:

* `Экономия памят`и: благодаря использованию пула строк, несколько строк с одинаковым значением будут использовать только один и тот же объект в памяти.
* `Быстродействие`: поиск в пуле строк занимает меньше времени, чем создание нового объекта, что может быть полезно в приложениях с большой нагрузкой.
* `Гарантированное поведение`: строковые литералы, которые объявлены в программе, всегда будут использовать пул строк и будут сравниваться между собой по значению, а не по ссылке.

Однако, следует помнить, что пул строк может привести к утечке памяти, когда строки попадают в пул, но не удаляются из него, даже если на них нет ссылок. Поэтому, при работе с большим количеством строк, следует обращать внимание на использование пула строк и правильно управлять памятью вашего приложения.





### **Какая разница между String, StringBuffer и StringBuilder?**

Java имеется три класса, позволяющих работать со строками: String, StringBuffer и StringBuilder.

Основное отличие между этими классами заключается в том, что String является неизменяемым классом, то есть каждая операция над объектом String приводит к созданию нового объекта. В свою очередь, классы StringBuffer и StringBuilder используются для работы с изменяемыми символьными последовательностями.

Класс StringBuffer был создан для того, чтобы решить проблему производительности при работе с изменяемыми строками. Он обеспечивает потокобезопасность, что позволяет использовать его в многопоточных приложениях. Однако, этот класс является менее эффективным по сравнению с StringBuilder.

Класс StringBuilder был добавлен в Java 5 как альтернатива StringBuffer. Он также обеспечивает возможность работы с изменяемыми строками, однако не является потокобезопасным. Зато он более эффективен по скорости выполнения операций.

Вот основные различия между классами String, StringBuffer и StringBuilder:

* `String - неизменяемый класс`, предназначенный для работы со строками. Каждый раз, когда выполняется операция над объектом String, создается новый объект, что может привести к ухудшению производительности.
* `StringBuffer - изменяемый класс для работы со строками`. Он обеспечивает потокобезопасность и более медленный, чем StringBuilder.
* `StringBuilder - также изменяемый класс для работы со строками`. Он не обеспечивает потокобезопасность, но при этом более быстрый по сравнению с StringBuffer.

Использование того или иного класса зависит от конкретной задачи. Если нужно работать со строками в многопоточном окружении, то лучше использовать StringBuffer. Если же нет необходимости в потокобезопасности, то для повышения производительности рекомендуется использовать StringBuilder. Наконец, если нужно работать с неизменяемой строкой, то используйте String.





### **Дайте краткую характеристику Enum в Java.**

Enum в Java - это перечислимый тип данных, который представляет собой набор именованных констант. Каждая константа представляет определенное значение из заданного списка значений. С помощью Enum можно создавать коллекции констант, которые могут использоваться в качестве аргументов для методов или свойств объектов. Кроме того, Enum обеспечивает безопасность типов, что означает, что используя константы Enum, можно избежать ошибок ввода-вывода и других ошибок, связанных с типами данных.

Пример кода создания Enum в Java:

```java
public enum DayOfWeek {
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY;
}
```





### **Что такое Stream в Java?**

`Stream (поток)`в Java - это объект, который представляет собой последовательность элементов данных и позволяет выполнять операции над этими элементами. Потоки предоставляют декларативный способ обработки данных без использования циклов.

Stream API добавлено в Java 8 и предоставляет множество операций для работы с потоками данных. Операции можно разделить на промежуточные и терминальные.

`Промежуточные операции`выполняются над элементами данных и возвращают новый поток. Примеры таких операций: filter(), map(), distinct(), sorted().

`Терминальные операции`завершают обработку потока данных и возвращают результат. Примеры таких операций: forEach(), toArray(), reduce(), collect().

Вместе с лямбда-выражениями Stream API позволяет работать с коллекциями и другими структурами данных более удобным и выразительным способом.





### **Назовите главные характеристики транзакций. Каковы уровни изоляции транзакций?**

`Транзакция (transaction)`- это последовательность операций, которые выполняются как единое целое и либо успешно завершаются, либо откатываются к начальному состоянию в случае возникновения ошибки.

Главные характеристики транзакций:

ACID-свойства - транзакции должны быть атомарными, согласованными, изолированными и долговечными.

* `Атомарность (Atomicity)`- все операции транзакции должны быть выполнены или не выполнены вообще.
* `Согласованность (Consistency)`- транзакция должна приводить базу данных в согласованное состояние.
* `Изолированность (Isolation)`- каждая транзакция должна работать в изолированном режиме, т.е. изменения, внесенные одной транзакцией, не должны видны другим транзакциям до тех пор, пока первая транзакция не будет завершена.
* `Долговечность (Durability)`- после успешного завершения транзакции изменения должны сохраняться в базе данных.

Уровень изоляции (isolation level) - определяет, насколько транзакции должны быть изолированы друг от друга. В Java есть четыре уровня изоляции:

* `READ UNCOMMITTED (чтение незафиксированных данных)`
* `READ COMMITTED (чтение зафиксированных данных)`
* `REPEATABLE READ (повторяемое чтение)`
* `SERIALIZABLE (сериализуемость)`

Уровень изоляции READ UNCOMMITTED позволяет одной транзакции видеть изменения, которые еще не были зафиксированы другой транзакцией. Уровень изоляции SERIALIZABLE обеспечивает полную изоляцию транзакций, при которой они ведут себя как будто выполняются последовательно, хотя фактически могут выполняться параллельно.





## Иерархия коллекций в Java Collection Framework выглядит следующим образом:

![](assets/XaVlv32hu3QCD4xpq_ZfSdHgk-4VJdQWkBjtCVq8eY0=.png)

* `Collection`- базовый интерфейс, предоставляющий методы для работы с группами объектов.
* `List`- интерфейс, представляющий упорядоченную коллекцию элементов, которые могут дублироваться.
* `Set`- интерфейс, представляющий неупорядоченную коллекцию уникальных элементов.
* `Queue`- интерфейс, представляющий коллекцию элементов, расположенных по порядку.
* `Deque`- интерфейс, представляющий двустороннюю очередь, в которой элементы могут добавляться и удаляться как с конца, так и с начала.
* `Map`- интерфейс, представляющий ассоциативную коллекцию пар "ключ-значение".
* `SortedSet`- интерфейс, представляющий отсортированное множество уникальных элементов.
* `SortedMap`- интерфейс, представляющий отсортированную ассоциативную коллекцию пар "ключ-значение".

Реализации этих интерфейсов можно найти в стандартной библиотеке Java. Например, ArrayList и LinkedList реализуют интерфейс List, HashSet и TreeSet - интерфейс Set, HashMap и TreeMap - интерфейс Map и т.д.







### **Каково внутреннее строение ArrayList?**

Внутреннее строение ArrayList в Java основано на массиве (array). Принцип работы заключается в создании массива определенной длины и последующей его заполнении элементами. Если массив становится недостаточно большим для хранения новых элементов, то создается новый массив большего размера и все элементы копируются в него. При этом, когда происходит добавление или удаление элементов из середины списка, все элементы после изменяемого сдвигаются вправо или влево соответственно.

Класс ArrayList имеет следующие поля:

* `elementData`- это массив, который используется для хранения элементов.
* `size`- это количество элементов в списке.
* `DEFAULT_CAPACITY`- это начальная емкость списка по умолчанию (10).
* `EMPTY_ELEMENTDATA`- это пустой массив, который используется при создании списка без указания начальной емкости.
* `MAX_ARRAY_SIZE`- это максимальный размер массива, который может быть создан в Java (2^31 - 1).

ArrayList предоставляет различные методы для добавления, удаления, поиска и обновления элементов списка. При использовании методов для добавления элементов, список автоматически увеличивает свою емкость при необходимости. Однако, при работе с большими объемами данных, необходимо следить за использованием памяти и настраивать начальную емкость списка для достижения лучшей производительности.





### **Каково внутреннее строение LinkedList?**

В Java,`LinkedList`- это класс, который представляет связанный список элементов. Внутренне LinkedList реализован как двусвязный список узлов, каждый из которых содержит ссылки на следующий и предыдущий узлы в списке, а также данные, хранящиеся в этом узле.

Когда элемент добавляется в LinkedList, он создает новый узел, содержащий данные и ссылки на предыдущий и следующий узлы. Этот узел затем добавляется в список путем обновления ссылок на соседние узлы в этих узлах.

Таким образом, LinkedList имеет следующую структуру:

```
class Node<E> {
    E item;
    Node<E> next;
    Node<E> prev;
}

public class LinkedList<E> {
    int size;
    Node<E> first;
    Node<E> last;
}
```

Здесь Node представляет узел в списке, а LinkedList представляет сам список. Каждый узел содержит элемент типа E (то есть хранит данные), а также ссылки на следующий и предыдущий узлы. Первый узел списка хранится в поле first, а последний - в поле last. Общее количество элементов в списке хранится в поле size.







### **Каково внутреннее устройство HashMap?**

Внутреннее устройство HashMap в Java основано на хэш-таблицах. Хэш-таблица - это структура данных, которая позволяет быстро и эффективно хранить пары ключ-значение и обеспечивает доступ к этим значениям за константное (O(1)) время в среднем случае.

Как работает HashMap:

* Каждый объект в HashMap имеет свой уникальный ключ.
* При добавлении элемента в HashMap, вычисляется хэш-код ключа с помощью метода hashCode() у ключа.
* Затем, для каждого хэш-кода вычисляется индекс массива, где будет храниться значение.
* Если два ключа имеют одинаковый хэш-код, они могут быть сохранены в одной ячейке массива, но будут храниться в односвязном списке в этой ячейке.
* Когда происходит запрос на получение значения по ключу, сначала вычисляется хэш-код ключа, затем определяется индекс массива, где может быть найдено значение. Если в этой ячейке есть список, пробегаем по списку, чтобы найти нужное значение.
* Важно отметить, что при использовании HashMap необходимо правильно переопределить методы equals() и hashCode() класса ключа, чтобы обеспечить правильное функционирование хэш-таблицы. Кроме того, когда количество элементов в HashMap достигает определенного порога, размер массива увеличивается автоматически для поддержания эффективности хранения и доступа к данным.





### **Для чего используют Equals and HashCode в Java? Расскажите о контракте между Equals and HashCode в Java?**

Equals и HashCode в Java используются для работы с объектами в коллекциях и для поддержания уникальности объектов.

`Метод equals()`используется для проверки равенства двух объектов. Для классов, которые не переопределили этот метод, он проверяет, являются ли два объекта ссылками на один и тот же объект в памяти. При переопределении метода equals() следует определить, какие поля объекта должны быть учтены при сравнении на равенство.

`Метод hashCode()`используется при работе с хеш-таблицами и другими алгоритмами, основанными на хеш-функциях. Он должен генерировать уникальный целочисленный код для каждого объекта класса. Это помогает быстро находить объекты в коллекции, используя хеш-функцию для поиска.

Контракт между методами equals() и hashCode() заключается в том, что если два объекта равны согласно методу equals(), то они должны иметь одинаковый hashCode(). Обратное правило не всегда верно: два объекта с одинаковым hashCode() могут быть не равными согласно методу equals(). Если этот контракт не выполняется, то объекты могут быть неправильно обрабатываться в хеш-таблицах и других алгоритмах, основанных на хеш-функциях.

При переопределении методов equals() и hashCode() следует придерживаться следующих правил:

* Если два объекта равны согласно методу equals(), то они должны иметь одинаковый hashCode().
* Для двух любых объектов класса, для которых equals() возвращает false, не требуется, чтобы их hashCode() были разными, но это может увеличить эффективность работы с хеш-таблицами.





### **Что такое коллизия в HashCode? Как с ней бороться?**

Коллизия в HashCode происходит, когда два разных значения имеют одинаковый хэш-код при использовании функции хэширования. Это может привести к тому, что разные элементы будут сохранены в одной и той же ячейке таблицы хешей, что может вызвать конфликты при поиске элементов.

Существует несколько способов борьбы с коллизиями.

* Один из них - это использование метода цепочек. В этом случае каждая ячейка таблицы хешей содержит связанный список всех элементов, которые получаются с помощью той же функции хэширования. Если возникает коллизия, новый элемент добавляется в этот связанный список.
* Другой способ - это использование метода открытой адресации. При использовании этого метода, если возникает коллизия, новый элемент добавляется в следующую доступную ячейку таблицы хешей. Этот процесс повторяется до тех пор, пока не будет найдена свободная ячейка, в которую можно поместить элемент.
* Третий способ - это изменение функции хэширования таким образом, чтобы она как можно меньше порождала коллизии. Например, можно использовать более сложную функцию хэширования или увеличить размер таблицы хешей.





### Н**апишите методы Equals and HashCode для класса Student, состоящего из полей String name и int age.**

```
public class Student {
    private String name;
    private int age;

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Student)) return false;
        Student student = (Student) o;
        return age == student.age &&
                Objects.equals(name, student.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
}
```





### **Дайте краткую характеристику метода clone().**

Метод clone() в Java предназначен для создания копии объекта. Клонированный объект является новым объектом, который содержит те же значения полей, что и исходный объект, но при этом является отдельным экземпляром класса.

Однако не все классы поддерживают метод clone(), поскольку он зависит от реализации интерфейса Cloneable. Если класс не реализует интерфейс Cloneable и попытаться вызвать метод clone(), то будет выброшено исключение CloneNotSupportedException.

Кроме этого, следует учитывать, что клонирование объектов может быть глубоким или поверхностным. В случае глубокого клонирования копируются также все ссылки на другие объекты, а при поверхностном клонировании копируются только значения примитивных типов и ссылки на другие объекты сохраняются как ссылки на оригинальные объекты.

Также стоит заметить, что метод clone() является защищенным методом, поэтому его можно вызвать только изнутри класса или его наследников.





### **Дайте определение понятию exception (исключительная ситуация).**

Exception (исключительная ситуация) - это объект, который представляет ошибку или исключительную ситуацию во время выполнения программы. Исключения могут возникать при обращении к данным, работе с файлами, сетевых операциях, неправильном использовании API и других ситуациях.

Когда возникает исключение, оно "бросается" (throws) из текущего метода, и программа ищет подходящий "обработчик" (handler), который может обработать это исключение. Если обработчик не найден, то программа завершает свою работу.

В Java исключения объединены в иерархическую структуру классов, начиная с класса Throwable. Два основных типа исключений в Java - это checked и unchecked исключения. Checked исключения должны быть обработаны в коде программы, иначе код не будет скомпилирован. Unchecked исключения (наследники класса RuntimeException) могут возникнуть в любой части кода и не требуют явной обработки.

Хорошая практика при работе с исключениями - это определить обработчики исключений для каждого метода, который может вызывать исключения, и обрабатывать их в соответствующем блоке try-catch. Также можно создавать пользовательские исключения для более точного определения ситуаций, которые могут возникнуть в программе.



### **Какова иерархия исключений?**

В Java, иерархия исключений начинается с класса Throwable. Throwable имеет два подкласса: Error и Exception.

Error представляет собой ошибки, которые происходят во время выполнения приложения, которые не могут быть обработаны программистом. Некоторые примеры таких ошибок включают в себя OutOfMemoryError, StackOverflowError и InternalError.

`Exception`- это класс, который представляет исключения, которые могут быть обработаны программистом. Он имеет несколько подклассов, включая RuntimeException и IOException.

`RuntimeException`является подклассом Exception, который описывает ошибки, которые могут быть обнаружены только во время выполнения программы, такие как NullPointerException или ArrayIndexOutOfBoundsException.

`IOException`- это подкласс Exception, который описывает ошибки, связанные с вводом/выводом, такие как FileNotFoundException.

`Throwable`также имеет два дополнительных подкласса: Checked и Unchecked. Checked является подклассом Exception и представляет проверяемые исключения, которые должны быть обработаны программистом, а Unchecked - это RuntimeException и его подклассы, которые не требуют обработки при компиляции кода.

При создании своих собственных классов исключений, вы можете наследовать как от класса Exception, так и от класса RuntimeException, чтобы создавать свои собственные типы исключений в Java.





## Жизненный цикл Spring компонента (Bean) включает несколько ключевых этапов:

1. **Instantiation (Создание экземпляра)**
   Spring создает объект компонента (Bean) с помощью конструктора. На этом этапе объект создается, но зависимости еще не внедрены.
2. **Populate properties (Внедрение зависимостей)**
   Заполняются все свойства и зависимости компонента, т.е. происходит внедрение зависимостей (Dependency Injection), через конструктор, сеттеры или поля.
3. **Aware-интерфейсы (Настройка контекста)**
   Если компонент реализует интерфейсы, например, BeanNameAware, BeanFactoryAware, ApplicationContextAware, Spring передает ему соответственно имя бина, BeanFactory или ApplicationContext для взаимодействия с контекстом.
4. **BeanPostProcessor до инициализации (Pre-initialization)**
   Вызывается метод**postProcessBeforeInitialization**всех BeanPostProcessor, которые могут выполнять дополнительные операции с бином перед инициализацией (валидация, изменение свойств и пр.).
5. **Инициализация (Initialization)**
   Spring вызывает методы инициализации бина:
   * метод, помеченный аннотацие&#x439;**@PostConstruct**,
   * метод**afterPropertiesSet()**&#x438;нтерфейса**InitializingBean**,
   * кастомный метод инициализации, если он указан в конфигурации.
6. **BeanPostProcessor после инициализации (Post-initialization)**
   Вызывается метод**postProcessAfterInitialization**всех BeanPostProcessor, что часто используется для создания прокси (например, для аспектов), оберток и других постобработок.
7. **Bean готов к использованию (Ready to use)**
   После всех вышеуказанных этапов бин считается готовым к использованию в приложении.
8. **Уничтожение (Destruction)**
   При завершении работы Spring контекста вызываются методы уничтожения:
   * метод, помеченный аннотацие&#x439;**@PreDestroy**,
   * метод**destroy()**&#x438;нтерфейса**DisposableBean**,
   * кастомный метод уничтожения, указанный в конфигурации.










CI/CD — это методология разработки программного обеспечения, которая объединяет процессы непрерывной интеграции (CI, Continuous Integration) и непрерывной доставки или развертывания (CD, Continuous Delivery/Continuous Deployment). Основная идея CI — это частое автоматическое объединение изменений кода разных разработчиков в общую ветку с последующим автоматическим построением и тестированием программы для выявления ошибок на ранних этапах. CD автоматизирует процесс доставки и установки программного обеспечения в продуктивную среду, тем самым позволяя быстро и регулярно выпускать новые версии с минимальным риском ошибок.



Непрерывная интеграция (CI) — это процесс, который помогает программистам быстрее и удобнее работать вместе. Представьте, что несколько людей пишут разные части одной программы. Они каждый день часто добавляют свои изменения в общую версию программы (репозиторий). При этом компьютер автоматически проверяет, что все части программы правильно "дружат" друг с другом, собирается и запускаются тесты, чтобы убедиться, что ничего не сломалось. Если есть ошибки, программисты сразу об этом узнают и быстро исправляют.

Это помогает быстро выявлять и исправлять ошибки, так как каждая новая "деталь" проверяется сразу, а не после того, как замок станет очень большим и сложным. Таким образом, CI — это автоматическая проверка и сборка работы каждого, чтобы всё было аккуратно и без ошибок.



CI/CD значительно ускоряет цикл разработки, повышает качество продукта за счет частого тестирования и автоматизации, снижает риск при релизах и экономит ресурсы команд разработки. Практика CI/CD широко применяется в современном DevOps для организации эффективного и надежного процесса разработки, тестирования и развертывания программного обеспечения. Она включает такие этапы, как коммит кода, автоматическая сборка, запуск тестов, деплой на тестовое окружение, а затем на продуктив, сопровождение и мониторинг продукта.













