
## 1. Использование `@WebMvcTest`

Аннотация `@WebMvcTest` ограничивает контекст Spring только контроллерами, что позволяет ускорить тесты и избежать загрузки лишных бинов (сервисы, репозитории и т.д.).

```java
@WebMvcTest(UserController.class)
public class UserControllerTest {
// ...
}
```


---

## 2. MockMvc для тестирования HTTP-взаимодействия

`MockMvc` позволяет тестировать поведение контроллера без запуска HTTP-сервера. Это позволяет проверить:

- Правильность обработки HTTP-запросов
- Статусы ответов
- Возвращаемые данные
- Валидацию данных

```java
@Test
void shouldReturnUser() throws Exception {
    mockMvc.perform(get("/users/1"))
           .andExpect(status().isOk())
           .andExpect(jsonPath("$.name").value("John"));
}
```


---

## 3. Мокирование сервисных слоев

Используйте `@MockBean` для мокирования сервисов, от которых зависит контроллер. Это позволяет изолировать тестирование контроллера от остальной логики.

```java
@MockBean
private UserService userService;
```

> Считается устаревшим подходом. В новых версиях рекомендовано использование MockitoBean

```java
@MockitoBean
private UserService userService;
```

- `@MockBean` из `spring-boot-test` был тесно связан с `spring-boot-test` и `Mockito`, но не был частью ядра `Spring Framework`.
- Введение `@MockitoBean` в `org.springframework.test.context.bean.override.mockito` делает тестирование более независимым от `Spring Boot` и более интегрированным с `Spring Framework`.
- Это позволяет использовать мокирование в тестах, не зависящих от `spring-boot-test`.

Пример использования:

```java
@SpringBootTest
class UserControllerTest {

    @MockitoBean
    private UserService userService;

    @Autowired
    private MockMvc mockMvc;

    @Test
    void shouldReturnUser() throws Exception {
        when(userService.findById(1L)).thenReturn(new User("John"));

        mockMvc.perform(get("/users/1"))
               .andExpect(status().isOk())
               .andExpect(jsonPath("$.name").value("John"));
    }
}
```


---

## 4. Использование `@AutoConfigureTestDatabase` и `@DataJpaTest` при наличии JPA

Если контроллер работает с JPA-репозиториями, можно использовать `@DataJpaTest` или `@AutoConfigureTestDatabase` для изоляции тестов от реальной БД.


---

## 5. Покрытие сценариев:

- Успешные запросы (200, 201, и т.д.)
- Ошибки валидации (400)
- Ошибки бизнес-логики (409, 404 и т.д.)
- Ошибки сервера (500)


---

## 6. Тестирование валидации (например, с `@Valid`)

Проверяйте, как контроллер реагирует на невалидные данные:

```java
@Test
void shouldReturn400WhenNameIsMissing() throws Exception {
    String invalidJson = """
        {
            "email": "john@example.com"
        }
        """;
    mockMvc.perform(post("/users")
           .contentType(MediaType.APPLICATION_JSON)
           .content(invalidJson))
           .andExpect(status().isBadRequest());
}
```


---

## 7. Использование `@TestConfiguration` и `@Import`

Если нужны специфичные бины для тестов (например, моки или заглушки), используйте `@TestConfiguration`.


---

## 8. Тестирование безопасности (если используется Spring Security)

Используйте `@WithMockUser` или `SecurityMockMvcRequestPostProcessors` для эмуляции аутентификации:

```java
@Test
@WithMockUser(roles = "ADMIN")
void shouldAccessAdminEndpoint() throws Exception {
    mockMvc.perform(get("/admin"))
           .andExpect(status().isOk());
}
```


---

## 9. Использование `@SpringBootTest` при интеграционных тестах

Если нужно протестировать полный стек (контроллер, сервисы, репозитории), используйте `@SpringBootTest` с `webEnvironment = WebEnvironment.RANDOM_PORT` и `@LocalServerPort`.


---

## 10. Использование `Testcontainers` для тестов с БД

Для интеграционных тестов с реальной БД рекомендуется использовать `Testcontainers` для запуска контейнера БД.


---

## 11. Использование `REST Assured` (альтернатива MockMvc)

`REST Assured` — альтернатива `MockMvc`, удобна для тестирования REST API с читаемым DSL:

```java
@Test
void shouldReturnUserWithRestAssured() {
    given()
        .when().get("/users/1")
        .then().statusCode(200)
        .body("name", equalTo("John"));
}
```


---

## 12. Повторное использование кода (Test Helpers / Test Data Builders)

Создавайте вспомогательные классы или методы для подготовки данных:

```java
public static User createUser() {
    return new User("John", "john@example.com");
}
```


---

## 13. Использование `@Nested` классов для структурирования тестов

Позволяет группировать тесты по функциональности:

```java
@Nested
class WhenUserExists {
    @Test
    void shouldReturnUser() { ... }
}

@Nested
class WhenUserDoesNotExist {
    @Test
    void shouldReturn404() { ... }
}
```

