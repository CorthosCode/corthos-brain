
## Зависимости

H2 уже встроен в Spring Boot Starter (если используешь `spring-boot-starter-data-jpa`), но если нет — добавь вручную:


Maven

```xml
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <scope>test</scope>
</dependency>
```


Gradle

```groovy
testImplementation 'com.h2database:h2'
```


***

## Конфигурация Spring Boot для H2

В `src/test/resources/application-test.yml`:

```yaml
spring:
  datasource:
    url: jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1
    driverClassName: org.h2.Driver
    username: sa
    password: 
  jpa:
    hibernate:
      ddl-auto: create-drop
    show-sql: true
```

⚠️ `DB_CLOSE_DELAY=-1` — база не закрывается между запросами в тесте. 

`create-drop` — автоматически создаёт и удаляет таблицы перед/после тестов.


***

## Тестовый класс

```java
package com.example.demo;

import com.example.demo.model.User;
import com.example.demo.repository.UserRepository;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.test.web.servlet.MockMvc;

import static org.mockito.Mockito.when;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;
import static org.assertj.core.api.Assertions.assertThat;

@SpringBootTest
@AutoConfigureMockMvc
class UserH2E2ETest {

    @Autowired
    MockMvc mockMvc;

    @Autowired
    UserRepository repo;

    @MockBean
    RestTemplate restTemplate;

    @Test
    void fullEndToEndTest_withH2() throws Exception {
        // Мокаем внешний API
        when(restTemplate.getForObject("https://api.example.com/city?name=Alice", String.class))
                .thenReturn("Paris");

        // Отправляем HTTP-запрос в контроллер
        mockMvc.perform(post("/users/Alice"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.name").value("Alice"))
                .andExpect(jsonPath("$.city").value("Paris"));

        // Проверяем запись в H2
        assertThat(repo.findAll())
                .extracting(User::getCity)
                .containsExactly("Paris");
    }
}
```


***

## Комбинированный подход

На практике часто делают так:

* **все тесты по умолчанию** — с H2 (быстро);
* **отдельный профиль** (`@ActiveProfiles("integration")`) — с Testcontainers;
* CI может запускать оба набора (например, nightly build с контейнерами).

